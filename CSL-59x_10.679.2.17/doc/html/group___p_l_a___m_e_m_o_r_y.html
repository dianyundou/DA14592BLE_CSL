<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1459x SDK: Non-Volatile Memory Devices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1459x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Non-Volatile Memory Devices<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___b_s_p.html">BSP (Board Support Package)</a> &raquo; <a class="el" href="group___p_l_a___b_s_p___s_y_s_t_e_m.html">System Configuration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Configuration values for the various supported qspi devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:eflash__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eflash__automode_8h.html">eflash_automode.h</a></td></tr>
<tr class="memdesc:eflash__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access EFLASH device when running in auto mode. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__automode_8h.html">qspi_automode.h</a></td></tr>
<tr class="memdesc:qspi__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access QSPI device when running in auto mode. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__automode__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__automode__v2_8h.html">qspi_automode_v2.h</a></td></tr>
<tr class="memdesc:qspi__automode__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Memory Abstraction Interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__common__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__common__v2_8h.html">qspi_common_v2.h</a></td></tr>
<tr class="memdesc:qspi__common__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver common definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__macronix__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__macronix__v2_8h.html">qspi_macronix_v2.h</a></td></tr>
<tr class="memdesc:qspi__macronix__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macros and functions of this header file are utilized by the memory drivers of the Macronix QSPI flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__mx25u3235__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__mx25u3235__v2_8h.html">qspi_mx25u3235_v2.h</a></td></tr>
<tr class="memdesc:qspi__mx25u3235__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Macronix MX25U3235_V2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__w25q32jwim__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__w25q32jwim__v2_8h.html">qspi_w25q32jwim_v2.h</a></td></tr>
<tr class="memdesc:qspi__w25q32jwim__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Winbond W25Q32JWIM_V2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__w25q32jwiq__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__w25q32jwiq__v2_8h.html">qspi_w25q32jwiq_v2.h</a></td></tr>
<tr class="memdesc:qspi__w25q32jwiq__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Winbond W25Q32JWIQ_V2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__winbond__v2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__winbond__v2_8h.html">qspi_winbond_v2.h</a></td></tr>
<tr class="memdesc:qspi__winbond__v2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macros and functions of this header file are utilized by the memory drivers of the Winbond QSPI flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjedec__id__t.html">jedec_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JEDEC ID struct.  <a href="structjedec__id__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__callback__t.html">qspi_callback_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI memory callbacks struct.  <a href="structqspi__callback__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__delay__t.html">qspi_delay_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI memory delays.  <a href="structqspi__delay__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__flash__config__t.html">qspi_flash_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI memory configuration structure.  <a href="structqspi__flash__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10cfb4e4b6222a22e1f2a18668b41bd9"><td class="memItemLeft" align="right" valign="top">const __RETAINED_CODE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga10cfb4e4b6222a22e1f2a18668b41bd9">eflash_automode_get_physical_addr</a> (uint32_t virtual_addr)</td></tr>
<tr class="memdesc:ga10cfb4e4b6222a22e1f2a18668b41bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical address of eFlash memory for the given virtual address.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga10cfb4e4b6222a22e1f2a18668b41bd9">More...</a><br /></td></tr>
<tr class="separator:ga10cfb4e4b6222a22e1f2a18668b41bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fa5ffe039a07362591f44cf36512e5"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaa2fa5ffe039a07362591f44cf36512e5">eflash_automode_is_valid_virtual_address_range</a> (uint32_t addr, uint32_t len)</td></tr>
<tr class="memdesc:gaa2fa5ffe039a07362591f44cf36512e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the virtual address range from <code>addr</code> to <code>addr</code> + <code>len</code> is valid.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaa2fa5ffe039a07362591f44cf36512e5">More...</a><br /></td></tr>
<tr class="separator:gaa2fa5ffe039a07362591f44cf36512e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a4f14ff1e0d24de8303d2ea540dfcef"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8a4f14ff1e0d24de8303d2ea540dfcef">eflash_automode_is_valid_virtual_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga8a4f14ff1e0d24de8303d2ea540dfcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if given virtual address points to EFLASH memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga8a4f14ff1e0d24de8303d2ea540dfcef">More...</a><br /></td></tr>
<tr class="separator:ga8a4f14ff1e0d24de8303d2ea540dfcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07d325140b345efd8f3d3cc0c9546e7"><td class="memItemLeft" align="right" valign="top">__ALWAYS_RETAINED_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7">eflash_automode_wakeup</a> (void)</td></tr>
<tr class="memdesc:gac07d325140b345efd8f3d3cc0c9546e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup EFLASH.  <a href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7">More...</a><br /></td></tr>
<tr class="separator:gac07d325140b345efd8f3d3cc0c9546e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9c51c81610dea6e1a30806ecd86e4f"><td class="memItemLeft" align="right" valign="top">__ALWAYS_RETAINED_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f">eflash_automode_sleep</a> (void)</td></tr>
<tr class="memdesc:gacc9c51c81610dea6e1a30806ecd86e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sef EFLASH to sleep mode.  <a href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f">More...</a><br /></td></tr>
<tr class="separator:gacc9c51c81610dea6e1a30806ecd86e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3427464d35473393d82f2a1d7c5991"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6b3427464d35473393d82f2a1d7c5991">eflash_automode_read</a> (uint32_t addr, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:ga6b3427464d35473393d82f2a1d7c5991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from EFLASH memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga6b3427464d35473393d82f2a1d7c5991">More...</a><br /></td></tr>
<tr class="separator:ga6b3427464d35473393d82f2a1d7c5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ca9ab7121ee5cb8c60a407193dae4d"><td class="memItemLeft" align="right" valign="top">__ALWAYS_RETAINED_CODE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad3ca9ab7121ee5cb8c60a407193dae4d">eflash_automode_write_page</a> (uint32_t addr, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:gad3ca9ab7121ee5cb8c60a407193dae4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to EFLASH memory page.  <a href="group___p_l_a___m_e_m_o_r_y.html#gad3ca9ab7121ee5cb8c60a407193dae4d">More...</a><br /></td></tr>
<tr class="separator:gad3ca9ab7121ee5cb8c60a407193dae4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a510712c4f734e9e146d60b1a58119a"><td class="memItemLeft" align="right" valign="top">__ALWAYS_RETAINED_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6a510712c4f734e9e146d60b1a58119a">eflash_automode_erase_sector</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga6a510712c4f734e9e146d60b1a58119a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase EFLASH sector.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga6a510712c4f734e9e146d60b1a58119a">More...</a><br /></td></tr>
<tr class="separator:ga6a510712c4f734e9e146d60b1a58119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f990c57c0849b2194fbb9a211b86e64"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2f990c57c0849b2194fbb9a211b86e64">eflash_automode_erase_chip</a> (void)</td></tr>
<tr class="memdesc:ga2f990c57c0849b2194fbb9a211b86e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase chip.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga2f990c57c0849b2194fbb9a211b86e64">More...</a><br /></td></tr>
<tr class="separator:ga2f990c57c0849b2194fbb9a211b86e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Configuration values for the various supported qspi devices. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2f990c57c0849b2194fbb9a211b86e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f990c57c0849b2194fbb9a211b86e64">&#9670;&nbsp;</a></span>eflash_automode_erase_chip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE bool eflash_automode_erase_chip </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase chip. </p>
<dl class="section return"><dt>Returns</dt><dd>true if chip was erased successfully, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If info page protection is enabled, it won't be erased.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7" title="Wakeup EFLASH.">eflash_automode_wakeup()</a> <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f" title="Sef EFLASH to sleep mode.">eflash_automode_sleep()</a> </dd></dl>

</div>
</div>
<a id="ga6a510712c4f734e9e146d60b1a58119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a510712c4f734e9e146d60b1a58119a">&#9670;&nbsp;</a></span>eflash_automode_erase_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ALWAYS_RETAINED_CODE bool eflash_automode_erase_sector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase EFLASH sector. </p>
<p>Erase EFLASH sector. Note that size of EFLASH sector is 0x800 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>sector address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if sector was erased successfully, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7" title="Wakeup EFLASH.">eflash_automode_wakeup()</a> <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f" title="Sef EFLASH to sleep mode.">eflash_automode_sleep()</a> </dd></dl>

</div>
</div>
<a id="ga10cfb4e4b6222a22e1f2a18668b41bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10cfb4e4b6222a22e1f2a18668b41bd9">&#9670;&nbsp;</a></span>eflash_automode_get_physical_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const __RETAINED_CODE void* eflash_automode_get_physical_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>virtual_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical address of eFlash memory for the given virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtual_addr</td><td>Virtual address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Use <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8a4f14ff1e0d24de8303d2ea540dfcef" title="Verify if given virtual address points to EFLASH memory.">eflash_automode_is_valid_virtual_addr()</a> to check whether the given virtual address is within the acceptable eFlash virtual address space area. If an invalid virtual address is passed to this function, the returned physical address will be invalid as well. The function doesn't check against invalid input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Physical address in CPU address space where data is located </dd></dl>

</div>
</div>
<a id="ga8a4f14ff1e0d24de8303d2ea540dfcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a4f14ff1e0d24de8303d2ea540dfcef">&#9670;&nbsp;</a></span>eflash_automode_is_valid_virtual_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE bool eflash_automode_is_valid_virtual_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if given virtual address points to EFLASH memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Virtual address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if virtual address points to EFLASH memory range, false otherwise </dd></dl>

</div>
</div>
<a id="gaa2fa5ffe039a07362591f44cf36512e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fa5ffe039a07362591f44cf36512e5">&#9670;&nbsp;</a></span>eflash_automode_is_valid_virtual_address_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE bool eflash_automode_is_valid_virtual_address_range </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the virtual address range from <code>addr</code> to <code>addr</code> + <code>len</code> is valid. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function requires virtual destination address. Do not provide physical or zero-based address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Virtual start address to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of bytes to access relative to the virtual start address, which determines the virtual end address to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if the input address virtual range is valid, otherwise false. </dd></dl>

</div>
</div>
<a id="ga6b3427464d35473393d82f2a1d7c5991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3427464d35473393d82f2a1d7c5991">&#9670;&nbsp;</a></span>eflash_automode_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t eflash_automode_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from EFLASH memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address pointing to EFLASH memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7" title="Wakeup EFLASH.">eflash_automode_wakeup()</a> <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f" title="Sef EFLASH to sleep mode.">eflash_automode_sleep()</a> </dd></dl>

</div>
</div>
<a id="gacc9c51c81610dea6e1a30806ecd86e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9c51c81610dea6e1a30806ecd86e4f">&#9670;&nbsp;</a></span>eflash_automode_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ALWAYS_RETAINED_CODE void eflash_automode_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sef EFLASH to sleep mode. </p>
<p>This function put EFLASH into sleep mode. </p>

</div>
</div>
<a id="gac07d325140b345efd8f3d3cc0c9546e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac07d325140b345efd8f3d3cc0c9546e7">&#9670;&nbsp;</a></span>eflash_automode_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ALWAYS_RETAINED_CODE void eflash_automode_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakeup EFLASH. </p>
<p>Call this function prior to <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6b3427464d35473393d82f2a1d7c5991" title="Read data from EFLASH memory.">eflash_automode_read()</a>, <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad3ca9ab7121ee5cb8c60a407193dae4d" title="Write data to EFLASH memory page.">eflash_automode_write_page()</a>, <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6a510712c4f734e9e146d60b1a58119a" title="Erase EFLASH sector.">eflash_automode_erase_sector()</a> and <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2f990c57c0849b2194fbb9a211b86e64" title="Erase chip.">eflash_automode_erase_chip()</a>. </p>

</div>
</div>
<a id="gad3ca9ab7121ee5cb8c60a407193dae4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ca9ab7121ee5cb8c60a407193dae4d">&#9670;&nbsp;</a></span>eflash_automode_write_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ALWAYS_RETAINED_CODE uint32_t eflash_automode_write_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to EFLASH memory page. </p>
<p>This function writes data do EFLASH memory. Note that EFLASH hardware supports writes of 32 bit words only, and if buffer or address is not word-aligned, flash content will be read, overwritten and written back to flash. Therefore word-aligned memory area should be erased before. Note that page boundary cannot be crossed and, as a result up to page size may be written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address pointing to EFLASH memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to write data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written bytes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac07d325140b345efd8f3d3cc0c9546e7" title="Wakeup EFLASH.">eflash_automode_wakeup()</a> <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacc9c51c81610dea6e1a30806ecd86e4f" title="Sef EFLASH to sleep mode.">eflash_automode_sleep()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2025 18:15:25 for SmartSnippets DA1459x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
