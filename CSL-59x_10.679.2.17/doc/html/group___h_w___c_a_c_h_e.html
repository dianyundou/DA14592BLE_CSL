<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1459x SDK: iCache Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1459x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iCache Controller<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___d_r_i_v_e_r_s.html">Drivers</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___m_e_m_o_r_y.html">Memory Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>iCache Controller LLD common API  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__cache_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__cache_8h.html">hw_cache.h</a></td></tr>
<tr class="memdesc:hw__cache_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the iCache Controller Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hw__cache__da1459x_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__cache__da1459x_8h.html">hw_cache_da1459x.h</a></td></tr>
<tr class="memdesc:hw__cache__da1459x_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of DA1459x specific API for the iCache Controller Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5629c89852d71dd11da8dba6c80e7eab"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a>) (void)</td></tr>
<tr class="memdesc:ga5629c89852d71dd11da8dba6c80e7eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application defined callback for the MRM interrupt.  <a href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">More...</a><br /></td></tr>
<tr class="separator:ga5629c89852d71dd11da8dba6c80e7eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga05b530fad9d14750fb49708cd8b099b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a> </td></tr>
<tr class="memdesc:ga05b530fad9d14750fb49708cd8b099b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cacheable eflash Region Sizes as defined in DA1459x datasheet.  <a href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">More...</a><br /></td></tr>
<tr class="separator:ga05b530fad9d14750fb49708cd8b099b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5db731d4daed45ab6570f2d979457dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> </td></tr>
<tr class="memdesc:gac5db731d4daed45ab6570f2d979457dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cacheable flash Region Sizes as defined in DA1459x datasheet.  <a href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">More...</a><br /></td></tr>
<tr class="separator:gac5db731d4daed45ab6570f2d979457dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15c6ac9e2869e341c338f036edbb894b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga15c6ac9e2869e341c338f036edbb894b">hw_cache_mrm_set_misses_thres</a> (uint32_t thres)</td></tr>
<tr class="memdesc:ga15c6ac9e2869e341c338f036edbb894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM interrupt threshold for misses.  <a href="group___h_w___c_a_c_h_e.html#ga15c6ac9e2869e341c338f036edbb894b">More...</a><br /></td></tr>
<tr class="separator:ga15c6ac9e2869e341c338f036edbb894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042acf2dd528d343409f2458fb59eb7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaa042acf2dd528d343409f2458fb59eb7">hw_cache_mrm_get_misses_thres</a> (void)</td></tr>
<tr class="memdesc:gaa042acf2dd528d343409f2458fb59eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM interrupt threshold for misses.  <a href="group___h_w___c_a_c_h_e.html#gaa042acf2dd528d343409f2458fb59eb7">More...</a><br /></td></tr>
<tr class="separator:gaa042acf2dd528d343409f2458fb59eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaab50dd16bc01c517e505c0bc4a66b60e">hw_cache_mrm_set_hits_thres</a> (uint32_t thres)</td></tr>
<tr class="memdesc:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM interrupt threshold for hits.  <a href="group___h_w___c_a_c_h_e.html#gaab50dd16bc01c517e505c0bc4a66b60e">More...</a><br /></td></tr>
<tr class="separator:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece12257a8c6f3cb3699f7661378842f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaece12257a8c6f3cb3699f7661378842f">hw_cache_mrm_get_hits_thres</a> (void)</td></tr>
<tr class="memdesc:gaece12257a8c6f3cb3699f7661378842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM interrupt threshold for hits.  <a href="group___h_w___c_a_c_h_e.html#gaece12257a8c6f3cb3699f7661378842f">More...</a><br /></td></tr>
<tr class="separator:gaece12257a8c6f3cb3699f7661378842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga02f877bb6a3bb3999c6229ebaaf9680e">hw_cache_mrm_get_misses_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM misses threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga02f877bb6a3bb3999c6229ebaaf9680e">More...</a><br /></td></tr>
<tr class="separator:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18af98472de537f4af4496fa34412e6d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga18af98472de537f4af4496fa34412e6d">hw_cache_mrm_clr_misses_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga18af98472de537f4af4496fa34412e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM misses threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga18af98472de537f4af4496fa34412e6d">More...</a><br /></td></tr>
<tr class="separator:ga18af98472de537f4af4496fa34412e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga89d269a059a7ac36dcc93c9c3aa53047">hw_cache_mrm_get_hits_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM hits threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga89d269a059a7ac36dcc93c9c3aa53047">More...</a><br /></td></tr>
<tr class="separator:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">hw_cache_mrm_clr_hits_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM hits threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">More...</a><br /></td></tr>
<tr class="separator:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga50baaa9ef1a4bb9bbe7832986fda9585">hw_cache_mrm_set_tint</a> (uint32_t tint)</td></tr>
<tr class="memdesc:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM monitoring time interval.  <a href="group___h_w___c_a_c_h_e.html#ga50baaa9ef1a4bb9bbe7832986fda9585">More...</a><br /></td></tr>
<tr class="separator:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0470d2492f249a0bf97743081fee47c0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga0470d2492f249a0bf97743081fee47c0">hw_cache_mrm_get_tint</a> (void)</td></tr>
<tr class="memdesc:ga0470d2492f249a0bf97743081fee47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM monitoring time interval.  <a href="group___h_w___c_a_c_h_e.html#ga0470d2492f249a0bf97743081fee47c0">More...</a><br /></td></tr>
<tr class="separator:ga0470d2492f249a0bf97743081fee47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga57d63128c10cd15f37d7b829ce2c9a15">hw_cache_mrm_get_tint_status</a> (void)</td></tr>
<tr class="memdesc:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM timer interval IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga57d63128c10cd15f37d7b829ce2c9a15">More...</a><br /></td></tr>
<tr class="separator:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaffbce6fba4487f7c77dc8fb24dae36c8">hw_cache_mrm_clr_tint_status</a> (void)</td></tr>
<tr class="memdesc:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM timer interval IRQ status.  <a href="group___h_w___c_a_c_h_e.html#gaffbce6fba4487f7c77dc8fb24dae36c8">More...</a><br /></td></tr>
<tr class="separator:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d33383047222cc93669b3db989642e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga07d33383047222cc93669b3db989642e">hw_cache_mrm_start_counters</a> (void)</td></tr>
<tr class="memdesc:ga07d33383047222cc93669b3db989642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start MRM counters.  <a href="group___h_w___c_a_c_h_e.html#ga07d33383047222cc93669b3db989642e">More...</a><br /></td></tr>
<tr class="separator:ga07d33383047222cc93669b3db989642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga2a52e77bc6d5eb104910df4ff02e202c">hw_cache_mrm_freeze_counters</a> (void)</td></tr>
<tr class="memdesc:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freeze MRM counters.  <a href="group___h_w___c_a_c_h_e.html#ga2a52e77bc6d5eb104910df4ff02e202c">More...</a><br /></td></tr>
<tr class="separator:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1515565552194cea562af1fd4b7d1afa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga1515565552194cea562af1fd4b7d1afa">hw_cache_mrm_get_misses</a> (void)</td></tr>
<tr class="memdesc:ga1515565552194cea562af1fd4b7d1afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM misses number.  <a href="group___h_w___c_a_c_h_e.html#ga1515565552194cea562af1fd4b7d1afa">More...</a><br /></td></tr>
<tr class="separator:ga1515565552194cea562af1fd4b7d1afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9a24961355cdee7e3279dc8989645a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gabf9a24961355cdee7e3279dc8989645a">hw_cache_mrm_set_misses</a> (uint32_t misses)</td></tr>
<tr class="memdesc:gabf9a24961355cdee7e3279dc8989645a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM cache misses number.  <a href="group___h_w___c_a_c_h_e.html#gabf9a24961355cdee7e3279dc8989645a">More...</a><br /></td></tr>
<tr class="separator:gabf9a24961355cdee7e3279dc8989645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga0d3d5651fb23ce09f7d5b87fac9b3284">hw_cache_mrm_get_hits</a> (void)</td></tr>
<tr class="memdesc:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM cache hits number.  <a href="group___h_w___c_a_c_h_e.html#ga0d3d5651fb23ce09f7d5b87fac9b3284">More...</a><br /></td></tr>
<tr class="separator:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gadd77a7961e527eab7796d5ccd56d6bf6">hw_cache_mrm_set_hits</a> (uint32_t hits)</td></tr>
<tr class="memdesc:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM cache hits number.  <a href="group___h_w___c_a_c_h_e.html#gadd77a7961e527eab7796d5ccd56d6bf6">More...</a><br /></td></tr>
<tr class="separator:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d7f102749e23ac9c59b58a4844aef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga23d7f102749e23ac9c59b58a4844aef5">hw_cache_mrm_enable_interrupt</a> (<a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga23d7f102749e23ac9c59b58a4844aef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the MRM interrupt generation.  <a href="group___h_w___c_a_c_h_e.html#ga23d7f102749e23ac9c59b58a4844aef5">More...</a><br /></td></tr>
<tr class="separator:ga23d7f102749e23ac9c59b58a4844aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851f28d720b3778761c2d5f26e626898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga851f28d720b3778761c2d5f26e626898">hw_cache_mrm_disable_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga851f28d720b3778761c2d5f26e626898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the MRM interrupt generation.  <a href="group___h_w___c_a_c_h_e.html#ga851f28d720b3778761c2d5f26e626898">More...</a><br /></td></tr>
<tr class="separator:ga851f28d720b3778761c2d5f26e626898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2df183c2b52b226502554a193466d37"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gad2df183c2b52b226502554a193466d37">hw_cache_enable</a> ()</td></tr>
<tr class="memdesc:gad2df183c2b52b226502554a193466d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the iCache Controller.  <a href="group___h_w___c_a_c_h_e.html#gad2df183c2b52b226502554a193466d37">More...</a><br /></td></tr>
<tr class="separator:gad2df183c2b52b226502554a193466d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a820e537770a75d4231d6cc3ddf5ed2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5a820e537770a75d4231d6cc3ddf5ed2">hw_cache_disable</a> ()</td></tr>
<tr class="memdesc:ga5a820e537770a75d4231d6cc3ddf5ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the iCache Controller.  <a href="group___h_w___c_a_c_h_e.html#ga5a820e537770a75d4231d6cc3ddf5ed2">More...</a><br /></td></tr>
<tr class="separator:ga5a820e537770a75d4231d6cc3ddf5ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecdef95c149f9cd50158750213a71b57"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaecdef95c149f9cd50158750213a71b57">hw_cache_is_enabled</a> ()</td></tr>
<tr class="memdesc:gaecdef95c149f9cd50158750213a71b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iCache Controller is enabled.  <a href="group___h_w___c_a_c_h_e.html#gaecdef95c149f9cd50158750213a71b57">More...</a><br /></td></tr>
<tr class="separator:gaecdef95c149f9cd50158750213a71b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391dd64abb0e016d623c00702f5b56dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga391dd64abb0e016d623c00702f5b56dc">hw_cache_set_extflash_cacheable_len</a> (uint32_t len)</td></tr>
<tr class="memdesc:ga391dd64abb0e016d623c00702f5b56dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the external (QSPI) flash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#ga391dd64abb0e016d623c00702f5b56dc">More...</a><br /></td></tr>
<tr class="separator:ga391dd64abb0e016d623c00702f5b56dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">hw_cache_get_extflash_cacheable_len</a> (void)</td></tr>
<tr class="memdesc:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the external (QSPI) flash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">More...</a><br /></td></tr>
<tr class="separator:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f03bb5e1b0d61288960a22c800c964"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga53f03bb5e1b0d61288960a22c800c964">hw_cache_set_eflash_cacheable_len</a> (uint32_t len)</td></tr>
<tr class="memdesc:ga53f03bb5e1b0d61288960a22c800c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eflash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#ga53f03bb5e1b0d61288960a22c800c964">More...</a><br /></td></tr>
<tr class="separator:ga53f03bb5e1b0d61288960a22c800c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ab815a5a6264b580eddc0e6d8aa54f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga98ab815a5a6264b580eddc0e6d8aa54f">hw_cache_get_eflash_cacheable_len</a> (void)</td></tr>
<tr class="memdesc:ga98ab815a5a6264b580eddc0e6d8aa54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eflash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#ga98ab815a5a6264b580eddc0e6d8aa54f">More...</a><br /></td></tr>
<tr class="separator:ga98ab815a5a6264b580eddc0e6d8aa54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gacb063c4ced8b37db07e30bfb2cc3cd00">hw_cache_set_len</a> (uint32_t len)</td></tr>
<tr class="memdesc:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cacheable memory length. Backwards compatibility wrapper.  <a href="group___h_w___c_a_c_h_e.html#gacb063c4ced8b37db07e30bfb2cc3cd00">More...</a><br /></td></tr>
<tr class="separator:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac571c4564be1ef5097831cb423b2d4ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gac571c4564be1ef5097831cb423b2d4ff">hw_cache_get_len</a> (void)</td></tr>
<tr class="memdesc:gac571c4564be1ef5097831cb423b2d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cacheable memory length. Backwards compatibility wrapper.  <a href="group___h_w___c_a_c_h_e.html#gac571c4564be1ef5097831cb423b2d4ff">More...</a><br /></td></tr>
<tr class="separator:gac571c4564be1ef5097831cb423b2d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="memItemLeft" align="right" valign="top"><a id="gaa2ceeb640ebb3aca7ea623eee2ebe07d"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaa2ceeb640ebb3aca7ea623eee2ebe07d">hw_cache_enable_flushing</a> (void)</td></tr>
<tr class="memdesc:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable flushing the iCache Controller (cache RAM cells) contents. For debugging only. <br /></td></tr>
<tr class="separator:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="memItemLeft" align="right" valign="top"><a id="gaef714fd3cacea08aca7fff7dd41c1ebe"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaef714fd3cacea08aca7fff7dd41c1ebe">hw_cache_disable_flushing</a> (void)</td></tr>
<tr class="memdesc:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable flushing the iCache Controller (cache RAM cells) contents. For debugging only. <br /></td></tr>
<tr class="separator:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c8bf920c97d5d030ab8c42dc9df5e4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga95c8bf920c97d5d030ab8c42dc9df5e4">hw_cache_is_flushing_disabled</a> ()</td></tr>
<tr class="memdesc:ga95c8bf920c97d5d030ab8c42dc9df5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iCache Controller flushing is disabled. For debugging only.  <a href="group___h_w___c_a_c_h_e.html#ga95c8bf920c97d5d030ab8c42dc9df5e4">More...</a><br /></td></tr>
<tr class="separator:ga95c8bf920c97d5d030ab8c42dc9df5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21654107b254110725ddacd01346412"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gae21654107b254110725ddacd01346412">hw_cache_flush</a> (void)</td></tr>
<tr class="memdesc:gae21654107b254110725ddacd01346412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the cache contents.  <a href="group___h_w___c_a_c_h_e.html#gae21654107b254110725ddacd01346412">More...</a><br /></td></tr>
<tr class="separator:gae21654107b254110725ddacd01346412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b17ac299cb4cfd6ec1cd2a4a672211"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gad0b17ac299cb4cfd6ec1cd2a4a672211">hw_cache_eflash_set_region_base</a> (eflash_region_base_t base)</td></tr>
<tr class="memdesc:gad0b17ac299cb4cfd6ec1cd2a4a672211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eflash region base.  <a href="group___h_w___c_a_c_h_e.html#gad0b17ac299cb4cfd6ec1cd2a4a672211">More...</a><br /></td></tr>
<tr class="separator:gad0b17ac299cb4cfd6ec1cd2a4a672211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ca2bc7b4de91101b19de59fda173e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE eflash_region_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga47ca2bc7b4de91101b19de59fda173e0">hw_cache_eflash_get_region_base</a> (void)</td></tr>
<tr class="memdesc:ga47ca2bc7b4de91101b19de59fda173e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eflash region base.  <a href="group___h_w___c_a_c_h_e.html#ga47ca2bc7b4de91101b19de59fda173e0">More...</a><br /></td></tr>
<tr class="separator:ga47ca2bc7b4de91101b19de59fda173e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1b0a6a7f55e6bef41f623b3bbc9b81"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5c1b0a6a7f55e6bef41f623b3bbc9b81">hw_cache_eflash_set_region_offset</a> (eflash_region_offset_t offset)</td></tr>
<tr class="memdesc:ga5c1b0a6a7f55e6bef41f623b3bbc9b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eflash region offset.  <a href="group___h_w___c_a_c_h_e.html#ga5c1b0a6a7f55e6bef41f623b3bbc9b81">More...</a><br /></td></tr>
<tr class="separator:ga5c1b0a6a7f55e6bef41f623b3bbc9b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3b031c72f4d7f1a0edfa35945b6681"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE eflash_region_offset_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga1f3b031c72f4d7f1a0edfa35945b6681">hw_cache_eflash_get_region_offset</a> (void)</td></tr>
<tr class="memdesc:ga1f3b031c72f4d7f1a0edfa35945b6681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eflash region offset.  <a href="group___h_w___c_a_c_h_e.html#ga1f3b031c72f4d7f1a0edfa35945b6681">More...</a><br /></td></tr>
<tr class="separator:ga1f3b031c72f4d7f1a0edfa35945b6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e9c5156e26041b3b186f628f855db4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga67e9c5156e26041b3b186f628f855db4">hw_cache_eflash_set_region_size</a> (<a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:ga67e9c5156e26041b3b186f628f855db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eflash region size.  <a href="group___h_w___c_a_c_h_e.html#ga67e9c5156e26041b3b186f628f855db4">More...</a><br /></td></tr>
<tr class="separator:ga67e9c5156e26041b3b186f628f855db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755b10c0d0f4db6b761787c6e06eb7a9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga755b10c0d0f4db6b761787c6e06eb7a9">hw_cache_eflash_get_region_size</a> (void)</td></tr>
<tr class="memdesc:ga755b10c0d0f4db6b761787c6e06eb7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eflash region size.  <a href="group___h_w___c_a_c_h_e.html#ga755b10c0d0f4db6b761787c6e06eb7a9">More...</a><br /></td></tr>
<tr class="separator:ga755b10c0d0f4db6b761787c6e06eb7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e9d452b87cbc41589b675e86a46ecd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gae1e9d452b87cbc41589b675e86a46ecd">hw_cache_eflash_configure_region</a> (eflash_region_base_t base, eflash_region_offset_t offset, <a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:gae1e9d452b87cbc41589b675e86a46ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the eflash memory region that will be cacheable.  <a href="group___h_w___c_a_c_h_e.html#gae1e9d452b87cbc41589b675e86a46ecd">More...</a><br /></td></tr>
<tr class="separator:gae1e9d452b87cbc41589b675e86a46ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6f61fb3179b2373be971d32f53217e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e">hw_cache_flash_set_region_base</a> (flash_region_base_t base)</td></tr>
<tr class="memdesc:gaef6f61fb3179b2373be971d32f53217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region base.  <a href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e">More...</a><br /></td></tr>
<tr class="separator:gaef6f61fb3179b2373be971d32f53217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3dc80229343ba08983c873c8cfadb5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE flash_region_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafc3dc80229343ba08983c873c8cfadb5">hw_cache_flash_get_region_base</a> (void)</td></tr>
<tr class="memdesc:gafc3dc80229343ba08983c873c8cfadb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region base.  <a href="group___h_w___c_a_c_h_e.html#gafc3dc80229343ba08983c873c8cfadb5">More...</a><br /></td></tr>
<tr class="separator:gafc3dc80229343ba08983c873c8cfadb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaea1ea0d5a8cfacfa39c6e6339a73a670">hw_cache_flash_set_region_offset</a> (flash_region_offset_t offset)</td></tr>
<tr class="memdesc:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region offset.  <a href="group___h_w___c_a_c_h_e.html#gaea1ea0d5a8cfacfa39c6e6339a73a670">More...</a><br /></td></tr>
<tr class="separator:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb8044d69a876bb2ab73a02074408f4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE flash_region_offset_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga3bb8044d69a876bb2ab73a02074408f4">hw_cache_flash_get_region_offset</a> (void)</td></tr>
<tr class="memdesc:ga3bb8044d69a876bb2ab73a02074408f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region offset.  <a href="group___h_w___c_a_c_h_e.html#ga3bb8044d69a876bb2ab73a02074408f4">More...</a><br /></td></tr>
<tr class="separator:ga3bb8044d69a876bb2ab73a02074408f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32c463d2527fad789e403ba750bd447"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447">hw_cache_flash_set_region_size</a> (<a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:gab32c463d2527fad789e403ba750bd447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region size.  <a href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447">More...</a><br /></td></tr>
<tr class="separator:gab32c463d2527fad789e403ba750bd447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe46dd7763e7a87de77e7f2321106f76"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafe46dd7763e7a87de77e7f2321106f76">hw_cache_flash_get_region_size</a> (void)</td></tr>
<tr class="memdesc:gafe46dd7763e7a87de77e7f2321106f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region size.  <a href="group___h_w___c_a_c_h_e.html#gafe46dd7763e7a87de77e7f2321106f76">More...</a><br /></td></tr>
<tr class="separator:gafe46dd7763e7a87de77e7f2321106f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gadaebf0eb7907c1c96a4c428d4617d5b3">hw_cache_flash_configure_region</a> (flash_region_base_t base, flash_region_offset_t offset, <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the flash memory region that will be cacheable.  <a href="group___h_w___c_a_c_h_e.html#gadaebf0eb7907c1c96a4c428d4617d5b3">More...</a><br /></td></tr>
<tr class="separator:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a362070011ed747f3a4f3b1ea988c8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga22a362070011ed747f3a4f3b1ea988c8">hw_cache_mrm_get_hits_with_one_wait_state</a> (void)</td></tr>
<tr class="memdesc:ga22a362070011ed747f3a4f3b1ea988c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM hits with 1 Wait State number.  <a href="group___h_w___c_a_c_h_e.html#ga22a362070011ed747f3a4f3b1ea988c8">More...</a><br /></td></tr>
<tr class="separator:ga22a362070011ed747f3a4f3b1ea988c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc291399ea5262bdd95c09d1a4d2b992"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafc291399ea5262bdd95c09d1a4d2b992">hw_cache_mrm_set_hits_with_one_wait_state</a> (uint32_t hits)</td></tr>
<tr class="memdesc:gafc291399ea5262bdd95c09d1a4d2b992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM hits with 1 Wait State number.  <a href="group___h_w___c_a_c_h_e.html#gafc291399ea5262bdd95c09d1a4d2b992">More...</a><br /></td></tr>
<tr class="separator:gafc291399ea5262bdd95c09d1a4d2b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>iCache Controller LLD common API </p>
<p>iCache Controller DA1459x specific LLD API</p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5629c89852d71dd11da8dba6c80e7eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5629c89852d71dd11da8dba6c80e7eab">&#9670;&nbsp;</a></span>hw_cache_mrm_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_cache_mrm_cb_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application defined callback for the MRM interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>The application defined callback should be declared as __RETAINED_CODE. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga05b530fad9d14750fb49708cd8b099b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05b530fad9d14750fb49708cd8b099b8">&#9670;&nbsp;</a></span>HW_CACHE_EFLASH_REGION_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cacheable eflash Region Sizes as defined in DA1459x datasheet. </p>

</div>
</div>
<a id="gac5db731d4daed45ab6570f2d979457dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5db731d4daed45ab6570f2d979457dc">&#9670;&nbsp;</a></span>HW_CACHE_FLASH_REGION_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cacheable flash Region Sizes as defined in DA1459x datasheet. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5a820e537770a75d4231d6cc3ddf5ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a820e537770a75d4231d6cc3ddf5ed2">&#9670;&nbsp;</a></span>hw_cache_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the iCache Controller. </p>
<p>The iCache Controller is disabled by setting the CACHERAM_MUX to '0'. This action disables the corresponding HW block, bypassing the iCache Controller for all read requests and letting the RAM memory of the block be visible in the entire memory space. </p>

</div>
</div>
<a id="gae1e9d452b87cbc41589b675e86a46ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1e9d452b87cbc41589b675e86a46ecd">&#9670;&nbsp;</a></span>hw_cache_eflash_configure_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_eflash_configure_region </td>
          <td>(</td>
          <td class="paramtype">eflash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eflash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the eflash memory region that will be cacheable. </p>
<p>This is an alternative API to <a class="el" href="group___h_w___c_a_c_h_e.html#gad0b17ac299cb4cfd6ec1cd2a4a672211" title="Set the eflash region base.">hw_cache_eflash_set_region_base()</a>/_size()/_offset(). It automatically configures the entire eflash region in one call.</p>
<p>See the relevant called functions for input parameter definition.</p>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="ga47ca2bc7b4de91101b19de59fda173e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ca2bc7b4de91101b19de59fda173e0">&#9670;&nbsp;</a></span>hw_cache_eflash_get_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE eflash_region_base_t hw_cache_eflash_get_region_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the eflash region base. </p>
<dl class="section return"><dt>Returns</dt><dd>The eflash region base to use with the cache </dd></dl>

</div>
</div>
<a id="ga1f3b031c72f4d7f1a0edfa35945b6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f3b031c72f4d7f1a0edfa35945b6681">&#9670;&nbsp;</a></span>hw_cache_eflash_get_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE eflash_region_offset_t hw_cache_eflash_get_region_offset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the eflash region offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The region offset to be used in conjunction with the region base to indicate the starting address within the eflash memory area that will be cacheable </dd></dl>

</div>
</div>
<a id="ga755b10c0d0f4db6b761787c6e06eb7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga755b10c0d0f4db6b761787c6e06eb7a9">&#9670;&nbsp;</a></span>hw_cache_eflash_get_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a> hw_cache_eflash_get_region_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the eflash region size. </p>
<dl class="section return"><dt>Returns</dt><dd>The eflash region size to use with the cache </dd></dl>

</div>
</div>
<a id="gad0b17ac299cb4cfd6ec1cd2a4a672211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b17ac299cb4cfd6ec1cd2a4a672211">&#9670;&nbsp;</a></span>hw_cache_eflash_set_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_eflash_set_region_base </td>
          <td>(</td>
          <td class="paramtype">eflash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the eflash region base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The eflash region base corresponds to the eflash address bits [31:16]. Default value is '0x00A0'. Bits [31:24] are fixed to '0x00'. Max value is thus 0x00FF and min 0x0000.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This should be aligned to the region size value (<a class="el" href="group___h_w___c_a_c_h_e.html#ga67e9c5156e26041b3b186f628f855db4" title="Set the eflash region size.">hw_cache_eflash_set_region_size()</a>). </dd>
<dd>
The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="ga5c1b0a6a7f55e6bef41f623b3bbc9b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1b0a6a7f55e6bef41f623b3bbc9b81">&#9670;&nbsp;</a></span>hw_cache_eflash_set_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_eflash_set_region_offset </td>
          <td>(</td>
          <td class="paramtype">eflash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the eflash region offset. </p>
<p>This value (expressed in words) is added to eflash region base (see hw_cache_eflash_set/get_region_base()) to calculate the the starting address within the eflash memory area that will be cacheable (remapped to 0x0) and XiPed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>eflash region offset in 32-bit words. Max: 0xFFF since the corresponding register bit field area is 3 nibbles in length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="ga67e9c5156e26041b3b186f628f855db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e9c5156e26041b3b186f628f855db4">&#9670;&nbsp;</a></span>hw_cache_eflash_set_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_eflash_set_region_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#ga05b530fad9d14750fb49708cd8b099b8">HW_CACHE_EFLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the eflash region size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The eflash region size to use with the cache</td></tr>
  </table>
  </dd>
</dl>
<p>This is the size of the eflash memory that will be cached. The size starts from eflash region base (see <a class="el" href="group___h_w___c_a_c_h_e.html#gad0b17ac299cb4cfd6ec1cd2a4a672211" title="Set the eflash region base.">hw_cache_eflash_set_region_base()</a>) plus eflash region offset (see <a class="el" href="group___h_w___c_a_c_h_e.html#ga5c1b0a6a7f55e6bef41f623b3bbc9b81" title="Set the eflash region offset.">hw_cache_eflash_set_region_offset()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gad2df183c2b52b226502554a193466d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2df183c2b52b226502554a193466d37">&#9670;&nbsp;</a></span>hw_cache_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the iCache Controller. </p>
<p>The iCache Controller is enabled by setting the CACHERAM_MUX to '1'. This action enables the corresponding HW block, letting the RAM memory of the block be visible only to the iCache Controller for caching purposes. </p>

</div>
</div>
<a id="gadaebf0eb7907c1c96a4c428d4617d5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaebf0eb7907c1c96a4c428d4617d5b3">&#9670;&nbsp;</a></span>hw_cache_flash_configure_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_configure_region </td>
          <td>(</td>
          <td class="paramtype">flash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the flash memory region that will be cacheable. </p>
<p>This is an alternative API to <a class="el" href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e" title="Set the flash region base.">hw_cache_flash_set_region_base()</a>/_size()/_offset(). It automatically configures the entire flash region in one call.</p>
<p>See the relevant called functions for input parameter definition.</p>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gafc3dc80229343ba08983c873c8cfadb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3dc80229343ba08983c873c8cfadb5">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE flash_region_base_t hw_cache_flash_get_region_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region base. </p>
<dl class="section return"><dt>Returns</dt><dd>The flash region base to use with the cache </dd></dl>

</div>
</div>
<a id="ga3bb8044d69a876bb2ab73a02074408f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb8044d69a876bb2ab73a02074408f4">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE flash_region_offset_t hw_cache_flash_get_region_offset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The region offset to be used in conjunction with the region base to indicate the starting address within the flash memory area that will be cacheable </dd></dl>

</div>
</div>
<a id="gafe46dd7763e7a87de77e7f2321106f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe46dd7763e7a87de77e7f2321106f76">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> hw_cache_flash_get_region_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region size. </p>
<dl class="section return"><dt>Returns</dt><dd>The flash region size to use with the cache </dd></dl>

</div>
</div>
<a id="gaef6f61fb3179b2373be971d32f53217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef6f61fb3179b2373be971d32f53217e">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_base </td>
          <td>(</td>
          <td class="paramtype">flash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The Flash region base corresponds to the flash address bits [31:16]. Bits [31:25] should be fixed to '0xb' and bits [17:16] should be fixed to '0x0'. Therefore, valid values are from 0x1600 to 0x17fc. This address should be 'size'-param aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This should be aligned to the region size value (<a class="el" href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447" title="Set the flash region size.">hw_cache_flash_set_region_size()</a>). </dd>
<dd>
The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gaea1ea0d5a8cfacfa39c6e6339a73a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea1ea0d5a8cfacfa39c6e6339a73a670">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_offset </td>
          <td>(</td>
          <td class="paramtype">flash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region offset. </p>
<p>This value (expressed in words) is added to flash region base (see hw_cache_flash_set/get_region_base()) to calculate the the starting address within the flash memory area that will be cacheable (remapped to 0x0) and XiPed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>flash region offset in 32-bit words. Max: 0xFFF since the corresponding register bit field area is 3 nibbles in length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gab32c463d2527fad789e403ba750bd447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32c463d2527fad789e403ba750bd447">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The flash region size to use with the cache</td></tr>
  </table>
  </dd>
</dl>
<p>This is the size of the flash memory that will be cached. The size starts from flash region base (see <a class="el" href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e" title="Set the flash region base.">hw_cache_flash_set_region_base()</a>) plus flash region offset (see <a class="el" href="group___h_w___c_a_c_h_e.html#gaea1ea0d5a8cfacfa39c6e6339a73a670" title="Set the flash region offset.">hw_cache_flash_set_region_offset()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gae21654107b254110725ddacd01346412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21654107b254110725ddacd01346412">&#9670;&nbsp;</a></span>hw_cache_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the cache contents. </p>
<p>Note: The very first flushing occurred after power on reset when the iCache Controller is enabled for the first time by the booter. </p>

</div>
</div>
<a id="ga98ab815a5a6264b580eddc0e6d8aa54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98ab815a5a6264b580eddc0e6d8aa54f">&#9670;&nbsp;</a></span>hw_cache_get_eflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int hw_cache_get_eflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the eflash cacheable memory length. </p>
<dl class="section return"><dt>Returns</dt><dd>The eflash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. </dd></dl>

</div>
</div>
<a id="gab10fc89bc6d6708b54d7c5a2b5e0cfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">&#9670;&nbsp;</a></span>hw_cache_get_extflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int hw_cache_get_extflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the external (QSPI) flash cacheable memory length. </p>
<dl class="section return"><dt>Returns</dt><dd>The eflash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. </dd></dl>

</div>
</div>
<a id="gac571c4564be1ef5097831cb423b2d4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac571c4564be1ef5097831cb423b2d4ff">&#9670;&nbsp;</a></span>hw_cache_get_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int hw_cache_get_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cacheable memory length. Backwards compatibility wrapper. </p>
<dl class="section return"><dt>Returns</dt><dd>See hw_cache_get_eflash_cacheable_len for details. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>API no longer supported, use hw_cache_get_eflash_cacheable_len. </dd></dl>

</div>
</div>
<a id="gaecdef95c149f9cd50158750213a71b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecdef95c149f9cd50158750213a71b57">&#9670;&nbsp;</a></span>hw_cache_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the iCache Controller is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iCache Controller is enabled, False otherwise. </dd></dl>

</div>
</div>
<a id="ga95c8bf920c97d5d030ab8c42dc9df5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c8bf920c97d5d030ab8c42dc9df5e4">&#9670;&nbsp;</a></span>hw_cache_is_flushing_disabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_flushing_disabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the iCache Controller flushing is disabled. For debugging only. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iCache Controller flushing is disabled, False otherwise. </dd></dl>

</div>
</div>
<a id="ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_hits_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_hits_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM hits threshold IRQ status. </p>

</div>
</div>
<a id="ga18af98472de537f4af4496fa34412e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18af98472de537f4af4496fa34412e6d">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_misses_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_misses_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM misses threshold IRQ status. </p>

</div>
</div>
<a id="gaffbce6fba4487f7c77dc8fb24dae36c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffbce6fba4487f7c77dc8fb24dae36c8">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_tint_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_tint_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM timer interval IRQ status. </p>

</div>
</div>
<a id="ga851f28d720b3778761c2d5f26e626898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga851f28d720b3778761c2d5f26e626898">&#9670;&nbsp;</a></span>hw_cache_mrm_disable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_cache_mrm_disable_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the MRM interrupt generation. </p>
<dl class="section note"><dt>Note</dt><dd>The application defined called is unregistered. </dd></dl>

</div>
</div>
<a id="ga23d7f102749e23ac9c59b58a4844aef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23d7f102749e23ac9c59b58a4844aef5">&#9670;&nbsp;</a></span>hw_cache_mrm_enable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_cache_mrm_enable_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the MRM interrupt generation. </p>
<p>The application should define its own callback. The latter is registered and then invoked when the MRM interrupt is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback defined by the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a52e77bc6d5eb104910df4ff02e202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a52e77bc6d5eb104910df4ff02e202c">&#9670;&nbsp;</a></span>hw_cache_mrm_freeze_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_freeze_counters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freeze MRM counters. </p>

</div>
</div>
<a id="ga0d3d5651fb23ce09f7d5b87fac9b3284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3d5651fb23ce09f7d5b87fac9b3284">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM cache hits number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of cache hits </dd></dl>

</div>
</div>
<a id="gaece12257a8c6f3cb3699f7661378842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece12257a8c6f3cb3699f7661378842f">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits_thres </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM interrupt threshold for hits. </p>
<dl class="section return"><dt>Returns</dt><dd>The interrupt generation threshold (in hits) </dd></dl>

</div>
</div>
<a id="ga89d269a059a7ac36dcc93c9c3aa53047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d269a059a7ac36dcc93c9c3aa53047">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_hits_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM hits threshold IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the number of hits reached the programmed threshold (if !=0) </dd></dl>

</div>
</div>
<a id="ga22a362070011ed747f3a4f3b1ea988c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a362070011ed747f3a4f3b1ea988c8">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_with_one_wait_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits_with_one_wait_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM hits with 1 Wait State number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of hits with 1 Wait State </dd></dl>

</div>
</div>
<a id="ga1515565552194cea562af1fd4b7d1afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1515565552194cea562af1fd4b7d1afa">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_misses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM misses number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of cache misses </dd></dl>

</div>
</div>
<a id="gaa042acf2dd528d343409f2458fb59eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa042acf2dd528d343409f2458fb59eb7">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_misses_thres </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM interrupt threshold for misses. </p>
<dl class="section return"><dt>Returns</dt><dd>The interrupt generation threshold (in misses) </dd></dl>

</div>
</div>
<a id="ga02f877bb6a3bb3999c6229ebaaf9680e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f877bb6a3bb3999c6229ebaaf9680e">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_misses_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM misses threshold IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the number of misses reached the programmed threshold (if !=0) </dd></dl>

</div>
</div>
<a id="ga0470d2492f249a0bf97743081fee47c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0470d2492f249a0bf97743081fee47c0">&#9670;&nbsp;</a></span>hw_cache_mrm_get_tint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_tint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM monitoring time interval. </p>
<dl class="section return"><dt>Returns</dt><dd>The monitoring time interval in clock cycles </dd></dl>

</div>
</div>
<a id="ga57d63128c10cd15f37d7b829ce2c9a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d63128c10cd15f37d7b829ce2c9a15">&#9670;&nbsp;</a></span>hw_cache_mrm_get_tint_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_tint_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM timer interval IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the time interval counter reached the end (time interval != 0). </dd></dl>

</div>
</div>
<a id="gadd77a7961e527eab7796d5ccd56d6bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd77a7961e527eab7796d5ccd56d6bf6">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM cache hits number. </p>
<p>This is primarily intended for clearing the hits number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hits</td><td>The number of cache hits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab50dd16bc01c517e505c0bc4a66b60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab50dd16bc01c517e505c0bc4a66b60e">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits_thres </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM interrupt threshold for hits. </p>
<p>Defines the threshold (in hits) to trigger the interrupt generation. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thres</td><td>The interrupt generation threshold (in hits) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc291399ea5262bdd95c09d1a4d2b992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc291399ea5262bdd95c09d1a4d2b992">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits_with_one_wait_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits_with_one_wait_state </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM hits with 1 Wait State number. </p>
<p>This is primarily intended for clearing the register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hits</td><td>The number of cache hits with 1 Wait State </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf9a24961355cdee7e3279dc8989645a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf9a24961355cdee7e3279dc8989645a">&#9670;&nbsp;</a></span>hw_cache_mrm_set_misses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_misses </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>misses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM cache misses number. </p>
<p>This is primarily intended for clearing the misses number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misses</td><td>The number of cache misses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15c6ac9e2869e341c338f036edbb894b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c6ac9e2869e341c338f036edbb894b">&#9670;&nbsp;</a></span>hw_cache_mrm_set_misses_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_misses_thres </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM interrupt threshold for misses. </p>
<p>Defines the threshold (in misses) to trigger the interrupt generation. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thres</td><td>The interrupt generation threshold (in misses) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50baaa9ef1a4bb9bbe7832986fda9585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50baaa9ef1a4bb9bbe7832986fda9585">&#9670;&nbsp;</a></span>hw_cache_mrm_set_tint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_tint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM monitoring time interval. </p>
<p>Defines the time interval for the monitoring in 32 MHz clock cycles. Must be an 19-bit value max. When this time is reached, an interrupt will be generated. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tint</td><td>Monitoring time interval in clock cycles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07d33383047222cc93669b3db989642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d33383047222cc93669b3db989642e">&#9670;&nbsp;</a></span>hw_cache_mrm_start_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_start_counters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start MRM counters. </p>
<dl class="section note"><dt>Note</dt><dd>If Timer interval is not set to 0 using hw_cache_mrm_set_tint, the timer interval will count down to 0. When zero is reached, an interrupt will be generated, and the counters will be disabled automatically. </dd></dl>

</div>
</div>
<a id="ga53f03bb5e1b0d61288960a22c800c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f03bb5e1b0d61288960a22c800c964">&#9670;&nbsp;</a></span>hw_cache_set_eflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_set_eflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the eflash cacheable memory length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The eflash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. Valid values: [0, 511]. A value of 0 sets the iCache Controller in bypass mode for the read requests targeting the cacheable eflash memory area. Any value greater than zero will set it in caching mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga391dd64abb0e016d623c00702f5b56dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391dd64abb0e016d623c00702f5b56dc">&#9670;&nbsp;</a></span>hw_cache_set_extflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_set_extflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the external (QSPI) flash cacheable memory length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The QSPI flash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. Valid values: [0, 511]. A value of 0 sets the iCache Controller in bypass mode for the read requests targeting the cacheable QSPI flash memory area. Any value greater than zero will set it in caching mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb063c4ced8b37db07e30bfb2cc3cd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb063c4ced8b37db07e30bfb2cc3cd00">&#9670;&nbsp;</a></span>hw_cache_set_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_set_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cacheable memory length. Backwards compatibility wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>See hw_cache_set_eflash_cacheable_len for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>API no longer supported, use hw_cache_set_eflash_cacheable_len. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2025 18:15:25 for SmartSnippets DA1459x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
