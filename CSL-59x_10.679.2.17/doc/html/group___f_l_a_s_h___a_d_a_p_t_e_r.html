<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1459x SDK: Flash Adapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1459x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash Adapter<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___a_d_a_p_t_e_r_s.html">System Adapters</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Flash Adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__flash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__flash_8h.html">ad_flash.h</a></td></tr>
<tr class="memdesc:ad__flash_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">AD_FLASH_ALWAYS_FLUSH_CACHE</a>&#160;&#160;&#160;((uint32_t) - 1)</td></tr>
<tr class="memdesc:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special base address used to return to the default cache flushing mode.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">More...</a><br /></td></tr>
<tr class="separator:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga502c902619ade1fd5c7f02538ae3cdc8">ad_flash_init</a> (void)</td></tr>
<tr class="memdesc:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the flash adapter.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga502c902619ade1fd5c7f02538ae3cdc8">More...</a><br /></td></tr>
<tr class="separator:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4df7b1a1a2c426240ee5d60d6437d880">ad_flash_read</a> (uint32_t addr, uint8_t *buf, size_t len)</td></tr>
<tr class="memdesc:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from flash memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4df7b1a1a2c426240ee5d60d6437d880">More...</a><br /></td></tr>
<tr class="separator:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf32898eb36d9af7b716badc7f9909ae9">ad_flash_write</a> (uint32_t addr, const uint8_t *buf, size_t size)</td></tr>
<tr class="memdesc:gaf32898eb36d9af7b716badc7f9909ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to flash memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf32898eb36d9af7b716badc7f9909ae9">More...</a><br /></td></tr>
<tr class="separator:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga6bc8fadbe7293f7adf1478a480d2f25d">ad_flash_erase_region</a> (uint32_t addr, size_t size)</td></tr>
<tr class="memdesc:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a flash memory region.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga6bc8fadbe7293f7adf1478a480d2f25d">More...</a><br /></td></tr>
<tr class="separator:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55347a10455406fd8765691489f3b841"><td class="memItemLeft" align="right" valign="top">const __STATIC_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga55347a10455406fd8765691489f3b841">ad_flash_get_ptr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga55347a10455406fd8765691489f3b841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a virtual address to a pointer that directly accesses the corresponding physical flash memory location.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga55347a10455406fd8765691489f3b841">More...</a><br /></td></tr>
<tr class="separator:ga55347a10455406fd8765691489f3b841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf815e083ba566721b2073b399d4f34d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf815e083ba566721b2073b399d4f34d4">ad_flash_update_possible</a> (uint32_t addr, const uint8_t *data_to_write, size_t size)</td></tr>
<tr class="memdesc:gaf815e083ba566721b2073b399d4f34d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a flash update can be performed without erasing memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf815e083ba566721b2073b399d4f34d4">More...</a><br /></td></tr>
<tr class="separator:gaf815e083ba566721b2073b399d4f34d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e2372a758d46c511356ce05920d1c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gad3e2372a758d46c511356ce05920d1c3">ad_flash_erase_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gad3e2372a758d46c511356ce05920d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum flash erasable size (sector size)  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gad3e2372a758d46c511356ce05920d1c3">More...</a><br /></td></tr>
<tr class="separator:gad3e2372a758d46c511356ce05920d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f73fc8cad96267323754fae67314e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4f73fc8cad96267323754fae67314e19">ad_flash_chip_erase_by_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga4f73fc8cad96267323754fae67314e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform full erase of a specified flash memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4f73fc8cad96267323754fae67314e19">More...</a><br /></td></tr>
<tr class="separator:ga4f73fc8cad96267323754fae67314e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599410ebcbd4ed9926998fc5bd786521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521">ad_flash_lock</a> (void)</td></tr>
<tr class="memdesc:ga599410ebcbd4ed9926998fc5bd786521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the flash adapter to prevent multiple tasks from accessing the same flash memory simultaneously.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521">More...</a><br /></td></tr>
<tr class="separator:ga599410ebcbd4ed9926998fc5bd786521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gafcf216c3b8d8a1cfefb1a08ab428a2d4">ad_flash_unlock</a> (void)</td></tr>
<tr class="memdesc:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock on flash adapter.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gafcf216c3b8d8a1cfefb1a08ab428a2d4">More...</a><br /></td></tr>
<tr class="separator:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa461b05c8ba275de7a21a628f562bc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61">ad_flash_skip_cache_flushing</a> (uint32_t base, uint32_t size)</td></tr>
<tr class="memdesc:gaa461b05c8ba275de7a21a628f562bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control cache flushing on modifications to a specified flash region.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61">More...</a><br /></td></tr>
<tr class="separator:gaa461b05c8ba275de7a21a628f562bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash Adapter. </p>
<dl class="section note"><dt>Note</dt><dd>The Flash Adapter should only be used with virtual addresses. Never pass physical or zero-based address. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gabb0ff70d27cb795c678201fa6eabb6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb0ff70d27cb795c678201fa6eabb6cb">&#9670;&nbsp;</a></span>AD_FLASH_ALWAYS_FLUSH_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AD_FLASH_ALWAYS_FLUSH_CACHE&#160;&#160;&#160;((uint32_t) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special base address used to return to the default cache flushing mode. </p>
<p>This constant can be used with the <code><code><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61" title="Control cache flushing on modifications to a specified flash region.">ad_flash_skip_cache_flushing()</a></code></code> function to reset the cache flushing behavior, so that all flash writes and erases will trigger cache flushing. The constant has the value of the maximum 32-bit unsigned integer, which is used as a sentinel value to indicate the special behavior. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4f73fc8cad96267323754fae67314e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f73fc8cad96267323754fae67314e19">&#9670;&nbsp;</a></span>ad_flash_chip_erase_by_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_flash_chip_erase_by_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform full erase of a specified flash memory. </p>
<p>The flash memory to be erased is specified by providing the corresponding virtual start address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual start address of the memory to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if the memory was successfully erased, false if the virtual start address is invalid. </dd></dl>

</div>
</div>
<a id="ga6bc8fadbe7293f7adf1478a480d2f25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc8fadbe7293f7adf1478a480d2f25d">&#9670;&nbsp;</a></span>ad_flash_erase_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_flash_erase_region </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a flash memory region. </p>
<p>This function erases all sectors from the virtual start address <code>addr</code> to <code>addr + size</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual start address of the flash region to be erased. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if the erase operation was successful.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <code>addr</code> is not sector-aligned, the preceding data of the sector where <code>addr</code> resides will also be erased. </dd>
<dd>
If <code>addr + size</code> is not sector aligned, the whole sector where the <code>addr + size</code> resides will also be erased. </dd></dl>

</div>
</div>
<a id="gad3e2372a758d46c511356ce05920d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e2372a758d46c511356ce05920d1c3">&#9670;&nbsp;</a></span>ad_flash_erase_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_erase_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum flash erasable size (sector size) </p>
<p>This function returns the minimum size that can be erased in flash memory, which corresponds to the sector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual address in flash memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum erasable size in bytes (sector size). </dd></dl>

</div>
</div>
<a id="ga55347a10455406fd8765691489f3b841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55347a10455406fd8765691489f3b841">&#9670;&nbsp;</a></span>ad_flash_get_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const __STATIC_INLINE void* ad_flash_get_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a virtual address to a pointer that directly accesses the corresponding physical flash memory location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual address to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the physical memory location corresponding to the given virtual address, or NULL if the virtual address is invalid. </dd></dl>

</div>
</div>
<a id="ga502c902619ade1fd5c7f02538ae3cdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga502c902619ade1fd5c7f02538ae3cdc8">&#9670;&nbsp;</a></span>ad_flash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the flash adapter. </p>
<p>This function is called by the system on power-up to initialize the flash adapter.</p>
<dl class="section warning"><dt>Warning</dt><dd>It should NOT be called by the application, as it is automatically executed at system start-up. </dd></dl>

</div>
</div>
<a id="ga599410ebcbd4ed9926998fc5bd786521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599410ebcbd4ed9926998fc5bd786521">&#9670;&nbsp;</a></span>ad_flash_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the flash adapter to prevent multiple tasks from accessing the same flash memory simultaneously. </p>
<p>This function gets the flash adapter for exclusive usage, ensuring that only one task can access the flash memory at any given time. </p>

</div>
</div>
<a id="ga4df7b1a1a2c426240ee5d60d6437d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df7b1a1a2c426240ee5d60d6437d880">&#9670;&nbsp;</a></span>ad_flash_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from flash memory. </p>
<p>This function reads a specified number of bytes from flash memory, starting from the virtual address specified in the addr parameter. The contents of the read data will be copied to the destination array pointed by the buf parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual address in flash memory to read data from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to the destination array in System RAM, where the read data will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read from flash memory. </dd></dl>

</div>
</div>
<a id="gaa461b05c8ba275de7a21a628f562bc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa461b05c8ba275de7a21a628f562bc61">&#9670;&nbsp;</a></span>ad_flash_skip_cache_flushing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_skip_cache_flushing </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control cache flushing on modifications to a specified flash region. </p>
<p>This function can be used to enable or disable the triggering of cache flushing when modifications (writes or erases) occur in a specific flash region. Only one such flash region can be defined.</p>
<p>This feature is useful when the programmer knows in advance that a large flash region is going to be updated (e.g. during firmware update). However, flash reads from that region should be avoided, as they might lead to cache incoherency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Starting offset of the flash region that should not trigger a cache flushing. If </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb" title="Special base address used to return to the default cache flushing mode.">AD_FLASH_ALWAYS_FLUSH_CACHE</a> is passed, selective cache flushing is disabled, regardless of the value of size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the flash region that should not trigger cache flushing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The effect of this function is limited to ad_flash_* layer and higher. Direct use of lower level APIs (e.g. hw_qspi_*, qspi_automode_* etc) will not be affected by the use of this function. </dd></dl>

</div>
</div>
<a id="gafcf216c3b8d8a1cfefb1a08ab428a2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf216c3b8d8a1cfefb1a08ab428a2d4">&#9670;&nbsp;</a></span>ad_flash_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release lock on flash adapter. </p>
<p>Release exclusive access to the flash adapter that was obtained using <code><code><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521" title="Lock the flash adapter to prevent multiple tasks from accessing the same flash memory simultaneously.">ad_flash_lock()</a></code></code>. This allows other tasks to use the flash adapter. </p>

</div>
</div>
<a id="gaf815e083ba566721b2073b399d4f34d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf815e083ba566721b2073b399d4f34d4">&#9670;&nbsp;</a></span>ad_flash_update_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_flash_update_possible </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a flash update can be performed without erasing memory. </p>
<p>This function checks if an update to flash memory can be performed without erasing the memory first. An update is possible only if only "0s" need to be written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual address in flash memory to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_to_write</td><td>Pointer to the source data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if an erase is required. Otherwise, a non-negative value representing the number of bytes that do not need to be written (i.e., the data is already the same as the new data). If the return value is 0, then the write operation should start from offset 0, but no erase is needed. </dd></dl>

</div>
</div>
<a id="gaf32898eb36d9af7b716badc7f9909ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32898eb36d9af7b716badc7f9909ae9">&#9670;&nbsp;</a></span>ad_flash_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to flash memory. </p>
<p>This function writes a specified number of bytes from a source data pointer to a virtual address in flash memory. Before writing to the destination virtual address, the memory at that location should be erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The virtual address in flash memory where the data will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the source data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to flash memory.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The memory at the destination virtual address should be erased before writing to it.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The source data pointer can also point to XiP (Execute-In-Place) mapped memory. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2025 18:15:25 for SmartSnippets DA1459x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
