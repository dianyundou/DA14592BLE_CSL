<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1459x SDK: Clock Manager Service</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1459x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Clock Manager Service<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___s_e_r_v_i_c_e_s.html">System Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Clock Manager.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sys__clock__mgr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__clock__mgr_8h.html">sys_clock_mgr.h</a></td></tr>
<tr class="memdesc:sys__clock__mgr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock Manager header file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">cm_sys_clk_init</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gad4e7df8e63e272869fcc340ece7b4d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize clocks after power-up.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">More...</a><br /></td></tr>
<tr class="separator:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">cm_sys_clk_set_priority</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> *sys_clk_prio_array)</td></tr>
<tr class="memdesc:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock priority.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">More...</a><br /></td></tr>
<tr class="separator:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ba9f84505f11a10eeb5ccdbb0123ed"><td class="memItemLeft" align="right" valign="top">cm_sys_clk_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed">cm_sys_clk_request</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gaa5ba9f84505f11a10eeb5ccdbb0123ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request for system clock switch.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed">More...</a><br /></td></tr>
<tr class="separator:gaa5ba9f84505f11a10eeb5ccdbb0123ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3027275ee4d7c2d1163a809b153e4315"><td class="memItemLeft" align="right" valign="top">cm_sys_clk_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315">cm_sys_clk_release</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:ga3027275ee4d7c2d1163a809b153e4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the system clock. It terminates a matching request.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315">More...</a><br /></td></tr>
<tr class="separator:ga3027275ee4d7c2d1163a809b153e4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c7649939d439045d58fec27c4b48c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">cm_apb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> div)</td></tr>
<tr class="memdesc:gaa4c7649939d439045d58fec27c4b48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA Peripheral Bus clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">More...</a><br /></td></tr>
<tr class="separator:gaa4c7649939d439045d58fec27c4b48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b18ecfc74a372db8f75ba23c974126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">cm_ahb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> div)</td></tr>
<tr class="memdesc:ga44b18ecfc74a372db8f75ba23c974126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA High speed Bus clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">More...</a><br /></td></tr>
<tr class="separator:ga44b18ecfc74a372db8f75ba23c974126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec75427c454e4476752fa28d8147b47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">cm_sys_clk_get</a> (void)</td></tr>
<tr class="memdesc:gaec75427c454e4476752fa28d8147b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">More...</a><br /></td></tr>
<tr class="separator:gaec75427c454e4476752fa28d8147b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7c573992fb1d59dd642ee3ef12177ae">cm_sys_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:gae7c573992fb1d59dd642ee3ef12177ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment (interrupt safe version).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7c573992fb1d59dd642ee3ef12177ae">More...</a><br /></td></tr>
<tr class="separator:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">cm_apb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga1c46e80c972a2214a394c62b9c60bc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA Peripheral Bus clock divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">More...</a><br /></td></tr>
<tr class="separator:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">cm_ahb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA High speed Bus clock divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">More...</a><br /></td></tr>
<tr class="separator:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c2817b0b31bec83ce2d4245766a300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">cm_cpu_clk_get</a> (void)</td></tr>
<tr class="memdesc:ga60c2817b0b31bec83ce2d4245766a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">More...</a><br /></td></tr>
<tr class="separator:ga60c2817b0b31bec83ce2d4245766a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7b31d79dea86dfba84b3a6dbd56bd9c9">cm_cpu_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency (interrupt safe).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7b31d79dea86dfba84b3a6dbd56bd9c9">More...</a><br /></td></tr>
<tr class="separator:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab11ec70b4d8cfa5a62a5dc672a8c32"><td class="memItemLeft" align="right" valign="top"><a id="ga2ab11ec70b4d8cfa5a62a5dc672a8c32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga2ab11ec70b4d8cfa5a62a5dc672a8c32">cm_calibrate_rclp</a> (void)</td></tr>
<tr class="memdesc:ga2ab11ec70b4d8cfa5a62a5dc672a8c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RCLP. <br /></td></tr>
<tr class="separator:ga2ab11ec70b4d8cfa5a62a5dc672a8c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cbc7436805ad427fdf34ecccc55e91d"><td class="memItemLeft" align="right" valign="top"><a id="ga5cbc7436805ad427fdf34ecccc55e91d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5cbc7436805ad427fdf34ecccc55e91d">cm_calibrate_rc32m</a> (void)</td></tr>
<tr class="memdesc:ga5cbc7436805ad427fdf34ecccc55e91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RC32M. <br /></td></tr>
<tr class="separator:ga5cbc7436805ad427fdf34ecccc55e91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">cm_rcx_us_2_lpcycles</a> (uint32_t usec)</td></tr>
<tr class="memdesc:gae884fa4c86df75b1cb87f591b9417e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts usec to RCX cycles.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">More...</a><br /></td></tr>
<tr class="separator:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">cm_rcx_us_2_lpcycles_low_acc</a> (uint32_t usec)</td></tr>
<tr class="memdesc:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts time to RCX cycles.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">More...</a><br /></td></tr>
<tr class="separator:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga73baf5e403b2eb3f68f01a2d53d06260">cm_wait_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the fast XTAL clock (XTALxxM) is ready. If the fast XTAL clock (XTALxxM) is running then the function exits immediately.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga73baf5e403b2eb3f68f01a2d53d06260">More...</a><br /></td></tr>
<tr class="separator:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ecd6fd016d5d67c3ce1714ecc2de8d4"><td class="memItemLeft" align="right" valign="top"><a id="ga8ecd6fd016d5d67c3ce1714ecc2de8d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8ecd6fd016d5d67c3ce1714ecc2de8d4">cm_rc_clocks_calibration_task_init</a> (void)</td></tr>
<tr class="memdesc:ga8ecd6fd016d5d67c3ce1714ecc2de8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the RCX calibration task. <br /></td></tr>
<tr class="separator:ga8ecd6fd016d5d67c3ce1714ecc2de8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9857796532a9d4e64156b009bd82fee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">cm_lp_clk_init</a> (void)</td></tr>
<tr class="memdesc:ga9857796532a9d4e64156b009bd82fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Low Power clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">More...</a><br /></td></tr>
<tr class="separator:ga9857796532a9d4e64156b009bd82fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1441219191476e451ba6fbc41bb9e103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1441219191476e451ba6fbc41bb9e103">cm_lp_clk_is_avail</a> (void)</td></tr>
<tr class="memdesc:ga1441219191476e451ba6fbc41bb9e103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1441219191476e451ba6fbc41bb9e103">More...</a><br /></td></tr>
<tr class="separator:ga1441219191476e451ba6fbc41bb9e103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8326d96c90e17710e709c0de96fc5e76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8326d96c90e17710e709c0de96fc5e76">cm_lp_clk_is_avail_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga8326d96c90e17710e709c0de96fc5e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available, interrupt safe version.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8326d96c90e17710e709c0de96fc5e76">More...</a><br /></td></tr>
<tr class="separator:ga8326d96c90e17710e709c0de96fc5e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">cm_wait_lp_clk_ready</a> (void)</td></tr>
<tr class="memdesc:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">More...</a><br /></td></tr>
<tr class="separator:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934fb28da416965225259e4964276456"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga934fb28da416965225259e4964276456">cm_lp_clk_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga934fb28da416965225259e4964276456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the flag that indicates that the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga934fb28da416965225259e4964276456">More...</a><br /></td></tr>
<tr class="separator:ga934fb28da416965225259e4964276456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade02a3d4827cc5d6df56c7596a885731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gade02a3d4827cc5d6df56c7596a885731">cm_wait_dblr_ready</a> (void)</td></tr>
<tr class="memdesc:gade02a3d4827cc5d6df56c7596a885731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the Doubler is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gade02a3d4827cc5d6df56c7596a885731">More...</a><br /></td></tr>
<tr class="separator:gade02a3d4827cc5d6df56c7596a885731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5356a34ab5e81acb542f55a0284b5c"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaed5356a34ab5e81acb542f55a0284b5c">cm_poll_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:gaed5356a34ab5e81acb542f55a0284b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the fast XTAL clock (XTALxxM) is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaed5356a34ab5e81acb542f55a0284b5c">More...</a><br /></td></tr>
<tr class="separator:gaed5356a34ab5e81acb542f55a0284b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f394c9ba43cf22a747795245cf4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac76f394c9ba43cf22a747795245cf4a7">cm_enable_xtalm</a> (void)</td></tr>
<tr class="memdesc:gac76f394c9ba43cf22a747795245cf4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the fast XTAL clock (XTALxxM)  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac76f394c9ba43cf22a747795245cf4a7">More...</a><br /></td></tr>
<tr class="separator:gac76f394c9ba43cf22a747795245cf4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b5e56bfe97a614a994c39807b7f979"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga31b5e56bfe97a614a994c39807b7f979">cm_sys_clk_sleep</a> (bool entering_sleep)</td></tr>
<tr class="memdesc:ga31b5e56bfe97a614a994c39807b7f979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock (unprotected).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga31b5e56bfe97a614a994c39807b7f979">More...</a><br /></td></tr>
<tr class="separator:ga31b5e56bfe97a614a994c39807b7f979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac523437b2bdff9ee4ca005d3f66e372d"><td class="memItemLeft" align="right" valign="top">__RETAINED_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac523437b2bdff9ee4ca005d3f66e372d">cm_halt_until_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:gac523437b2bdff9ee4ca005d3f66e372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until the fast XTAL clock (XTALxxM) has settled.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac523437b2bdff9ee4ca005d3f66e372d">More...</a><br /></td></tr>
<tr class="separator:gac523437b2bdff9ee4ca005d3f66e372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56ed15acc5f7574a4ef86dea5840326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab56ed15acc5f7574a4ef86dea5840326">cm_register_xtal_ready_callback</a> (void(*cb)(void))</td></tr>
<tr class="memdesc:gab56ed15acc5f7574a4ef86dea5840326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function to be called then XTAL32M is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab56ed15acc5f7574a4ef86dea5840326">More...</a><br /></td></tr>
<tr class="separator:gab56ed15acc5f7574a4ef86dea5840326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661682b3995c84cc5868142896f6fd63"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga661682b3995c84cc5868142896f6fd63">cm_halt_until_sysclk_ready</a> (void)</td></tr>
<tr class="memdesc:ga661682b3995c84cc5868142896f6fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until system clock (either PLL or XTAL32M) is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga661682b3995c84cc5868142896f6fd63">More...</a><br /></td></tr>
<tr class="separator:ga661682b3995c84cc5868142896f6fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Clock Manager. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga462965cf64536f7d5d6f9c72b5f3e4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462965cf64536f7d5d6f9c72b5f3e4e9">&#9670;&nbsp;</a></span>cm_ahb_get_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> cm_ahb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA High speed Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The hclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga44b18ecfc74a372db8f75ba23c974126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b18ecfc74a372db8f75ba23c974126">&#9670;&nbsp;</a></span>cm_ahb_set_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_ahb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA High speed Bus clock. </p>
<p>The frequency of the AHB clock is (system_clock / (1 &lt;&lt; cm_ahbclk)). Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the AHB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the divider was changed to the requested value, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga1c46e80c972a2214a394c62b9c60bc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c46e80c972a2214a394c62b9c60bc22">&#9670;&nbsp;</a></span>cm_apb_get_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA Peripheral Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The pclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gaa4c7649939d439045d58fec27c4b48c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c7649939d439045d58fec27c4b48c2">&#9670;&nbsp;</a></span>cm_apb_set_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_apb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA Peripheral Bus clock. </p>
<p>The frequency of the APB clock is (system_clock / (1 &lt;&lt; cm_ahbclk)) / (1 &lt;&lt; cm_apbclk).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the APB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga60c2817b0b31bec83ce2d4245766a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60c2817b0b31bec83ce2d4245766a300">&#9670;&nbsp;</a></span>cm_cpu_clk_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any restrictions of the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e" title="Returns the sys_clk that the system uses at that moment.">cm_sys_clk_get()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9" title="Returns the AMBA High speed Bus clock divider.">cm_ahb_get_clock_divider()</a> apply here as well. It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga7b31d79dea86dfba84b3a6dbd56bd9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b31d79dea86dfba84b3a6dbd56bd9c9">&#9670;&nbsp;</a></span>cm_cpu_clk_get_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency (interrupt safe). </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gac76f394c9ba43cf22a747795245cf4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76f394c9ba43cf22a747795245cf4a7">&#9670;&nbsp;</a></span>cm_enable_xtalm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_enable_xtalm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the fast XTAL clock (XTALxxM) </p>
<p>Checks if the fast XTAL clock (XTALxxM) is started. If not, it checks if there is a PDC entry for starting the fast XTAL clock (XTALxxM). If there is, it uses PDC to start the fast XTAL clock (XTALxxM). Otherwise, it enables the fast XTAL clock (XTALxxM) using <a class="el" href="group___h_w___c_l_k.html#ga2fc015f080bb3c75682d74591b2611ee" title="Activate a System clock.">hw_clk_enable_sysclk()</a>. </p>

</div>
</div>
<a id="ga661682b3995c84cc5868142896f6fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661682b3995c84cc5868142896f6fd63">&#9670;&nbsp;</a></span>cm_halt_until_sysclk_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_halt_until_sysclk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until system clock (either PLL or XTAL32M) is ready. </p>
<p>It executes a WFI() call waiting for the XTALxxM Ready interrupt and PLL LOCK interrupt if needed. </p>

</div>
</div>
<a id="gac523437b2bdff9ee4ca005d3f66e372d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac523437b2bdff9ee4ca005d3f66e372d">&#9670;&nbsp;</a></span>cm_halt_until_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE void cm_halt_until_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until the fast XTAL clock (XTALxxM) has settled. </p>
<p>It executes a WFI() call waiting for the fast XTAL clock (XTALxxM) Ready interrupt. Any other interrupts that hit are served. </p>

</div>
</div>
<a id="ga9857796532a9d4e64156b009bd82fee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9857796532a9d4e64156b009bd82fee2">&#9670;&nbsp;</a></span>cm_lp_clk_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Low Power clock. </p>
<p>It initializes and sets as LP clock either the RCX or the XTAL32K. Since the XTAL32K settling takes a long time, the system is kept in active mode until this completes. </p>

</div>
</div>
<a id="ga1441219191476e451ba6fbc41bb9e103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1441219191476e451ba6fbc41bb9e103">&#9670;&nbsp;</a></span>cm_lp_clk_is_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga8326d96c90e17710e709c0de96fc5e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8326d96c90e17710e709c0de96fc5e76">&#9670;&nbsp;</a></span>cm_lp_clk_is_avail_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available, interrupt safe version. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga934fb28da416965225259e4964276456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga934fb28da416965225259e4964276456">&#9670;&nbsp;</a></span>cm_lp_clk_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE void cm_lp_clk_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the flag that indicates that the Low Power clock is available. </p>
<p>It is called when the system wakes up from a "forced" deep sleep state and the XTAL32K is used as the LP clock so that the system won't enter into sleep until the crystal has settled.</p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gaed5356a34ab5e81acb542f55a0284b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5356a34ab5e81acb542f55a0284b5c">&#9670;&nbsp;</a></span>cm_poll_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE bool cm_poll_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the fast XTAL clock (XTALxxM) is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the fast XTAL clock (XTALxxM) has settled, else false. </dd></dl>

</div>
</div>
<a id="gae884fa4c86df75b1cb87f591b9417e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae884fa4c86df75b1cb87f591b9417e2b">&#9670;&nbsp;</a></span>cm_rcx_us_2_lpcycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_CODE uint32_t cm_rcx_us_2_lpcycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts usec to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Maximum time period is 4.095msec. </dd></dl>

</div>
</div>
<a id="ga64bbd9cd49b18ce46a71fa41ae287587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64bbd9cd49b18ce46a71fa41ae287587">&#9670;&nbsp;</a></span>cm_rcx_us_2_lpcycles_low_acc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cm_rcx_us_2_lpcycles_low_acc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts time to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a low accuracy function. To have good accuracy, the minimum time period should be 1msec and the maximum 200msec. Above 200msec, the function calculates more RCX cycles than necessary. </dd></dl>

</div>
</div>
<a id="gab56ed15acc5f7574a4ef86dea5840326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56ed15acc5f7574a4ef86dea5840326">&#9670;&nbsp;</a></span>cm_register_xtal_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_register_xtal_ready_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function to be called then XTAL32M is ready. </p>
<p>cb pointer to the callback function </p>

</div>
</div>
<a id="gaec75427c454e4476752fa28d8147b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec75427c454e4476752fa28d8147b47e">&#9670;&nbsp;</a></span>cm_sys_clk_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment. </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gae7c573992fb1d59dd642ee3ef12177ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c573992fb1d59dd642ee3ef12177ae">&#9670;&nbsp;</a></span>cm_sys_clk_get_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment (interrupt safe version). </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system. </dd></dl>

</div>
</div>
<a id="gad4e7df8e63e272869fcc340ece7b4d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e7df8e63e272869fcc340ece7b4d79">&#9670;&nbsp;</a></span>cm_sys_clk_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize clocks after power-up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as the system clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called with interrupts enabled! It must be called only once, after power-up. </dd></dl>

</div>
</div>
<a id="ga3027275ee4d7c2d1163a809b153e4315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3027275ee4d7c2d1163a809b153e4315">&#9670;&nbsp;</a></span>cm_sys_clk_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cm_sys_clk_status_t cm_sys_clk_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the system clock. It terminates a matching request. </p>
<p>If there are other sys_clk requests that are still active (i.e. not released), the system will switch to the one that has the highest priority. Otherwise, it will switch to the initial sys_clk that was specified when <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize clocks after power-up.">cm_sys_clk_init()</a> was called. No change however will be made if Div1 is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source the system was requested to use, when the matching <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed" title="Request for system clock switch.">cm_sys_clk_request()</a> was called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success if the release operation was completed successfully and either triggered a switch to a lower_priority sys_clk or did not trigger any sys_clk_change (either because there are still other active requests for the same sys_clk that have not been released yet or because there are no other active requests and the released sys_clk is also the default one (as specified in <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize clocks after power-up.">cm_sys_clk_init()</a>)) </dd>
<dd>
cm_sysclk_div1_clk_in_use if the release operation was completed successfully and it should normally trigger a new sys_clk change (based on other active requests) but it didn't because a peripheral is clocked by the Div1 clock</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called ONLY for terminating a matching cm_sys_clk_request. If called alone the system will reach an error-state!</dd>
<dd>
It cannot be called from Interrupt Context.</dd>
<dd>
It may block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed" title="Request for system clock switch.">cm_sys_clk_request</a> </dd></dl>

</div>
</div>
<a id="gaa5ba9f84505f11a10eeb5ccdbb0123ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ba9f84505f11a10eeb5ccdbb0123ed">&#9670;&nbsp;</a></span>cm_sys_clk_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cm_sys_clk_status_t cm_sys_clk_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request for system clock switch. </p>
<p>This function can be used for system clock switching. It requests from the Clock Manager to use a specific clock source as system clock (sys_clk). If this is possible, the request is accepted and the function switches the sys_clk setting to the selected clock source and returns cm_sysclk_success. Otherwise, the request is rejected and the function returns a value that denotes the reason why the switch was not possible.</p>
<p>The request can be cancelled/released later by calling <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a>. Until then, the requested sys_clk is protected from any lower priority sys_clk requests (with the priority as defined by <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a>).</p>
<p>There are two reasons that make the switching of the system clock not possible. Either there is at least one peripheral that currently uses the Div1 clock, or the current system clock has higher priority and is currently in use. In the second case, a successful switch requires a preceding release operation.</p>
<p>If the request involves enabling the fast Xtal clock (XTAL32M), then, apart from powering on the XTAL32M, the function will wait for it to settle before setting it as sys_clk. If the Doubler is requested, the function will also wait for the Doubler to be available.</p>
<p>The Clock Manager will also take care of automatically restoring the sys_clk to the requested setting after each wake-up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as sys_clk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success if the requested sys_clk switch was applied </dd>
<dd>
cm_sysclk_div1_clk_in_use if the sys_clk cannot be switched because a peripheral is clocked by the Div1 clock </dd>
<dd>
cm_sysclk_higher_prio_used if a higher priority system clock is still in use</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires a preceding call of <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a>.</dd>
<dd>
Even if the request is rejected, it is still taken into account (until cancelled by a corresponding <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> call), and the switch to the requested clock may take place later (e.g. as soon as the existing higher priority clock requests are released).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a> </dd>
<dd>
<a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> </dd></dl>

</div>
</div>
<a id="gae838f7f275a650999c7b4dd4d6b6ee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae838f7f275a650999c7b4dd4d6b6ee45">&#9670;&nbsp;</a></span>cm_sys_clk_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_set_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> *&#160;</td>
          <td class="paramname"><em>sys_clk_prio_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock priority. </p>
<p>The system clock priority indicates which sys_clk prevails against another one when requesting a new sys_clk using <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed" title="Request for system clock switch.">cm_sys_clk_request()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk_prio_array</td><td>pointer to array containing the system clock priority (in decreasing order)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The provided array is expected to hold the first three members of the sys_clk_t enum in the order that denotes the desired priority scheme, with each type appearing only once in the array and the first element denoting the highest priority sys_clk. In case the array contains more elements, only the first three are taken into account.</dd>
<dd>
The default clocks priority in decreasing order is the following: sysclk_DBLR64 sysclk_XTAL32M sysclk_RC32</dd></dl>
<p>The application can select a different clock priorities order by creating a local temporary priorities struct instance with the clocks in the desired priority order and then call the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a> like in the example below. If the priorities are not set by the application before the first call of <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed" title="Request for system clock switch.">cm_sys_clk_request()</a> or <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a>, then the default priorities will be applied.</p>
<div class="fragment"><div class="line"><a class="code" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk_p[] = {</div>
<div class="line">                             <a class="code" href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2aebab417cd5b504331b20664494f6b4e7">sysclk_DBLR64</a>,</div>
<div class="line">                             <a class="code" href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2a2abcc1da6529daeef88f73362f097e96">sysclk_XTAL32M</a>,</div>
<div class="line">                             <a class="code" href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2a3e463bd9c840bf272459a1f8c3fee810">sysclk_RC32</a></div>
<div class="line">                  };</div>
<div class="line"> </div>
<div class="line">                  <a class="code" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">cm_sys_clk_set_priority</a>(sys_clk_p);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It has to be called only once, after power-up and before calling <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize clocks after power-up.">cm_sys_clk_init()</a>. If not called the default clocks priority is used.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa5ba9f84505f11a10eeb5ccdbb0123ed" title="Request for system clock switch.">cm_sys_clk_request()</a> </dd>
<dd>
<a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga3027275ee4d7c2d1163a809b153e4315" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> </dd></dl>

</div>
</div>
<a id="ga31b5e56bfe97a614a994c39807b7f979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b5e56bfe97a614a994c39807b7f979">&#9670;&nbsp;</a></span>cm_sys_clk_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_sys_clk_sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>entering_sleep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock (unprotected). </p>
<p>It attempts to:</p><ul>
<li>Prepare the system clock for sleep : called when the system is entering power-down mode. The system clock settings of the application are kept in order to be able to restore them. If the PLL is active it will be turned off. (It is called with the scheduler stopped and all interrupts disabled in this case.)</li>
<li>Restore the previous setting : called when the fast XTAL clock (XTALxxM) settles. (It is called from ISR context with all interrupts disabled in this case.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entering_sleep</td><td>true if the system is going to sleep, else false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and/or with all interrupts disabled. The function is internal to the clock and power managers and should not be used externally! </dd></dl>

</div>
</div>
<a id="gade02a3d4827cc5d6df56c7596a885731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade02a3d4827cc5d6df56c7596a885731">&#9670;&nbsp;</a></span>cm_wait_dblr_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_dblr_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the Doubler is ready. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga6dcfa191a663cbc9e2998e79cbc7b68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcfa191a663cbc9e2998e79cbc7b68e">&#9670;&nbsp;</a></span>cm_wait_lp_clk_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_lp_clk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the Low Power clock is available. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga73baf5e403b2eb3f68f01a2d53d06260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73baf5e403b2eb3f68f01a2d53d06260">&#9670;&nbsp;</a></span>cm_wait_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the fast XTAL clock (XTALxxM) is ready. If the fast XTAL clock (XTALxxM) is running then the function exits immediately. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup___h_w___c_l_k_html_gga80b42bde28ce2d446fe9e1895a11c5b2a3e463bd9c840bf272459a1f8c3fee810"><div class="ttname"><a href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2a3e463bd9c840bf272459a1f8c3fee810">sysclk_RC32</a></div><div class="ttdoc">RC32.</div><div class="ttdef"><b>Definition:</b> hw_clk_da1459x.h:130</div></div>
<div class="ttc" id="agroup___c_l_o_c_k___m_a_n_a_g_e_r_html_gae838f7f275a650999c7b4dd4d6b6ee45"><div class="ttname"><a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">cm_sys_clk_set_priority</a></div><div class="ttdeci">void cm_sys_clk_set_priority(sys_clk_t *sys_clk_prio_array)</div><div class="ttdoc">Set the system clock priority.</div></div>
<div class="ttc" id="agroup___h_w___c_l_k_html_gga80b42bde28ce2d446fe9e1895a11c5b2a2abcc1da6529daeef88f73362f097e96"><div class="ttname"><a href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2a2abcc1da6529daeef88f73362f097e96">sysclk_XTAL32M</a></div><div class="ttdoc">32MHz</div><div class="ttdef"><b>Definition:</b> hw_clk_da1459x.h:131</div></div>
<div class="ttc" id="agroup___h_w___c_l_k_html_ga42297fa8f8149da6ac66c67b57a3704e"><div class="ttname"><a href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a></div><div class="ttdeci">enum sysclk_type sys_clk_t</div><div class="ttdoc">The system clock type.</div></div>
<div class="ttc" id="agroup___h_w___c_l_k_html_gga80b42bde28ce2d446fe9e1895a11c5b2aebab417cd5b504331b20664494f6b4e7"><div class="ttname"><a href="group___h_w___c_l_k.html#gga80b42bde28ce2d446fe9e1895a11c5b2aebab417cd5b504331b20664494f6b4e7">sysclk_DBLR64</a></div><div class="ttdoc">64MHz</div><div class="ttdef"><b>Definition:</b> hw_clk_da1459x.h:132</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2025 18:15:25 for SmartSnippets DA1459x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
