<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1459x SDK: SPI Adapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1459x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI Adapter<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___a_d_a_p_t_e_r_s.html">System Adapters</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adapter for SPI controller.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__spi_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__spi_8h.html">ad_spi.h</a></td></tr>
<tr class="memdesc:ad__spi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Controller access API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__spi__io__conf__t.html">ad_spi_io_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI I/O configuration.  <a href="structad__spi__io__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__spi__driver__conf__t.html">ad_spi_driver_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI driver configuration.  <a href="structad__spi__driver__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__spi__controller__conf__t.html">ad_spi_controller_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI controller configuration.  <a href="structad__spi__controller__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="memItemLeft" align="right" valign="top"><a id="ga66d27ad5bdb4d305d0967f9172566b8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga66d27ad5bdb4d305d0967f9172566b8a">CONFIG_SPI_USE_ASYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether SPI asynchronous transaction API will be used. <br /></td></tr>
<tr class="separator:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20acb91cdacd34ba0cdf441bfb68118b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga20acb91cdacd34ba0cdf441bfb68118b">CONFIG_SPI_USE_SYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga20acb91cdacd34ba0cdf441bfb68118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether SPI synchronous transaction API will be used.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga20acb91cdacd34ba0cdf441bfb68118b">More...</a><br /></td></tr>
<tr class="separator:ga20acb91cdacd34ba0cdf441bfb68118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf393399e8a808b2ab8e0f0e4d10ed0bd"><td class="memItemLeft" align="right" valign="top"><a id="gaf393399e8a808b2ab8e0f0e4d10ed0bd"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a></td></tr>
<tr class="memdesc:gaf393399e8a808b2ab8e0f0e4d10ed0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Handle returned by <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> <br /></td></tr>
<tr class="separator:gaf393399e8a808b2ab8e0f0e4d10ed0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaab5bb3d688adc44b0881b3df6b031522"><td class="memItemLeft" align="right" valign="top"><a id="gaab5bb3d688adc44b0881b3df6b031522"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaab5bb3d688adc44b0881b3df6b031522">AD_SPI_ERROR</a> </td></tr>
<tr class="memdesc:gaab5bb3d688adc44b0881b3df6b031522"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum with return values of API calls <br /></td></tr>
<tr class="separator:gaab5bb3d688adc44b0881b3df6b031522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7c1b395ea7ac0145fbe72ead8c5e0643">ad_spi_init</a> (void)</td></tr>
<tr class="memdesc:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga7c1b395ea7ac0145fbe72ead8c5e0643">More...</a><br /></td></tr>
<tr class="separator:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6cb5779fa025745f6c390d17db7347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347">ad_spi_open</a> (const <a class="el" href="structad__spi__controller__conf__t.html">ad_spi_controller_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gacd6cb5779fa025745f6c390d17db7347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open SPI controller.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347">More...</a><br /></td></tr>
<tr class="separator:gacd6cb5779fa025745f6c390d17db7347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4bde8796de722afe47f30e731bec2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga4a4bde8796de722afe47f30e731bec2f">ad_spi_reconfig</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const <a class="el" href="structad__spi__driver__conf__t.html">ad_spi_driver_conf_t</a> *drv_conf)</td></tr>
<tr class="memdesc:ga4a4bde8796de722afe47f30e731bec2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure SPI controller.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga4a4bde8796de722afe47f30e731bec2f">More...</a><br /></td></tr>
<tr class="separator:ga4a4bde8796de722afe47f30e731bec2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bc5d728492bf6daea7208723d1ee8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga87bc5d728492bf6daea7208723d1ee8f">ad_spi_close</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, bool force)</td></tr>
<tr class="memdesc:ga87bc5d728492bf6daea7208723d1ee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close SPI controller.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga87bc5d728492bf6daea7208723d1ee8f">More...</a><br /></td></tr>
<tr class="separator:ga87bc5d728492bf6daea7208723d1ee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2433f44e8607af03fc159aad3e1e5361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga2433f44e8607af03fc159aad3e1e5361">ad_spi_io_config</a> (HW_SPI_ID id, const <a class="el" href="structad__spi__io__conf__t.html">ad_spi_io_conf_t</a> *io, <a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a> state)</td></tr>
<tr class="memdesc:ga2433f44e8607af03fc159aad3e1e5361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize controller pins to on / off io configuration.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga2433f44e8607af03fc159aad3e1e5361">More...</a><br /></td></tr>
<tr class="separator:ga2433f44e8607af03fc159aad3e1e5361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf999ddb5965f123661f8939ccaa83ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gadf999ddb5965f123661f8939ccaa83ff">ad_spi_write</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const uint8_t *wbuf, size_t wlen)</td></tr>
<tr class="memdesc:gadf999ddb5965f123661f8939ccaa83ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking write transaction.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gadf999ddb5965f123661f8939ccaa83ff">More...</a><br /></td></tr>
<tr class="separator:gadf999ddb5965f123661f8939ccaa83ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f2023f35dc3e7aef1380dfae9b4007"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa0f2023f35dc3e7aef1380dfae9b4007">ad_spi_read</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, uint8_t *rbuf, size_t rlen)</td></tr>
<tr class="memdesc:gaa0f2023f35dc3e7aef1380dfae9b4007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking read transaction.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gaa0f2023f35dc3e7aef1380dfae9b4007">More...</a><br /></td></tr>
<tr class="separator:gaa0f2023f35dc3e7aef1380dfae9b4007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2136e116fc5f113e2c8aa2b8b06e20d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa2136e116fc5f113e2c8aa2b8b06e20d">ad_spi_write_read</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const uint8_t *wbuf, uint8_t *rbuf, size_t len)</td></tr>
<tr class="memdesc:gaa2136e116fc5f113e2c8aa2b8b06e20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking write and read transaction.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gaa2136e116fc5f113e2c8aa2b8b06e20d">More...</a><br /></td></tr>
<tr class="separator:gaa2136e116fc5f113e2c8aa2b8b06e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6598d61382f20e7f11f5ae6ec7c51163"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga6598d61382f20e7f11f5ae6ec7c51163">ad_spi_activate_cs</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, uint8_t csid)</td></tr>
<tr class="memdesc:ga6598d61382f20e7f11f5ae6ec7c51163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate chip select for a specific device.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga6598d61382f20e7f11f5ae6ec7c51163">More...</a><br /></td></tr>
<tr class="separator:ga6598d61382f20e7f11f5ae6ec7c51163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b271bffb3c40f465ccd046f01e596b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga3b271bffb3c40f465ccd046f01e596b1">ad_spi_deactivate_cs</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle)</td></tr>
<tr class="memdesc:ga3b271bffb3c40f465ccd046f01e596b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate chip select for a specific device.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga3b271bffb3c40f465ccd046f01e596b1">More...</a><br /></td></tr>
<tr class="separator:ga3b271bffb3c40f465ccd046f01e596b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c731511211c18b084eed63072908fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa4c731511211c18b084eed63072908fe">ad_spi_deactivate_cs_when_spi_done</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle)</td></tr>
<tr class="memdesc:gaa4c731511211c18b084eed63072908fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for SPI interface to be idle and deactivate chip select.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gaa4c731511211c18b084eed63072908fe">More...</a><br /></td></tr>
<tr class="separator:gaa4c731511211c18b084eed63072908fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae932834a8881d369ecd99554dadd00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga0ae932834a8881d369ecd99554dadd00">ad_spi_write_async</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const uint8_t *wbuf, size_t wlen, ad_spi_user_cb cb, void *user_data)</td></tr>
<tr class="memdesc:ga0ae932834a8881d369ecd99554dadd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a non blocking write transaction.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#ga0ae932834a8881d369ecd99554dadd00">More...</a><br /></td></tr>
<tr class="separator:ga0ae932834a8881d369ecd99554dadd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28b8e6b379690f4ecdfb52d920849f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gab28b8e6b379690f4ecdfb52d920849f9">ad_spi_read_async</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const uint8_t *rbuf, size_t rlen, ad_spi_user_cb cb, void *user_data)</td></tr>
<tr class="memdesc:gab28b8e6b379690f4ecdfb52d920849f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking read transaction.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gab28b8e6b379690f4ecdfb52d920849f9">More...</a><br /></td></tr>
<tr class="separator:gab28b8e6b379690f4ecdfb52d920849f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa631aa63d1612b22b634b649d0283d1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa631aa63d1612b22b634b649d0283d1d">ad_spi_write_read_async</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> handle, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, ad_spi_user_cb cb, void *user_data)</td></tr>
<tr class="memdesc:gaa631aa63d1612b22b634b649d0283d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform asynchronous SPI write and then read transaction. It can be used as write command and read buffer operation.  <a href="group___s_p_i___a_d_a_p_t_e_r.html#gaa631aa63d1612b22b634b649d0283d1d">More...</a><br /></td></tr>
<tr class="separator:gaa631aa63d1612b22b634b649d0283d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adapter for SPI controller. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga20acb91cdacd34ba0cdf441bfb68118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20acb91cdacd34ba0cdf441bfb68118b">&#9670;&nbsp;</a></span>CONFIG_SPI_USE_SYNC_TRANSACTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_USE_SYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether SPI synchronous transaction API will be used. </p>
<p>SPI synchronous transaction API maintains state in retention RAM for every SPI bus declared. If the API is not to be used, setting this macro to 0 will save retention RAM. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6598d61382f20e7f11f5ae6ec7c51163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6598d61382f20e7f11f5ae6ec7c51163">&#9670;&nbsp;</a></span>ad_spi_activate_cs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_activate_cs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>csid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate chip select for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">csid</td><td>The index in the CS list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The task must own the controller before calling this function </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only by SPI master. </dd></dl>

</div>
</div>
<a id="ga87bc5d728492bf6daea7208723d1ee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87bc5d728492bf6daea7208723d1ee8f">&#9670;&nbsp;</a></span>ad_spi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close SPI controller. </p>
<p>This function:</p><ul>
<li>Aborts ongoing transactions</li>
<li>De-initializes the drivers associated with the controller</li>
<li>Resets controller interface IOs (as specified in <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a>)</li>
<li>Releases the controller resources</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>force close and abort ongoing transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </dd></dl>

</div>
</div>
<a id="ga3b271bffb3c40f465ccd046f01e596b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b271bffb3c40f465ccd046f01e596b1">&#9670;&nbsp;</a></span>ad_spi_deactivate_cs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_deactivate_cs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate chip select for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The task must own the bus before calling this function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only by SPI master. </dd></dl>

</div>
</div>
<a id="gaa4c731511211c18b084eed63072908fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c731511211c18b084eed63072908fe">&#9670;&nbsp;</a></span>ad_spi_deactivate_cs_when_spi_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_deactivate_cs_when_spi_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for SPI interface to be idle and deactivate chip select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The device and the bus resources must have been acquired before calling this function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only by SPI master. </dd></dl>

</div>
</div>
<a id="ga7c1b395ea7ac0145fbe72ead8c5e0643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1b395ea7ac0145fbe72ead8c5e0643">&#9670;&nbsp;</a></span>ad_spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize adapter. </p>
<dl class="section note"><dt>Note</dt><dd>It should ONLY be called by the system. </dd></dl>

</div>
</div>
<a id="ga2433f44e8607af03fc159aad3e1e5361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2433f44e8607af03fc159aad3e1e5361">&#9670;&nbsp;</a></span>ad_spi_io_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_io_config </td>
          <td>(</td>
          <td class="paramtype">HW_SPI_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__spi__io__conf__t.html">ad_spi_io_conf_t</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize controller pins to on / off io configuration. </p>
<p>This function should be called for setting pins to the correct level before external devices are powered up (e.g on system init). It does not need to be called before every <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>controller io configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>on/off io configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code </dd></dl>

</div>
</div>
<a id="gacd6cb5779fa025745f6c390d17db7347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd6cb5779fa025745f6c390d17db7347">&#9670;&nbsp;</a></span>ad_spi_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a> ad_spi_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structad__spi__controller__conf__t.html">ad_spi_controller_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open SPI controller. </p>
<p>This function:</p><ul>
<li>Acquires the resources needed for using the controller</li>
<li>Configures the controller interface IOs. The CS (SPI enable pin) is the first in the relevant I/O list.</li>
<li>Initializes the drivers associated with the controller</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>controller configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0: handle that should be used in subsequent API calls, NULL: error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function will block until it acquires all controller resources </dd></dl>

</div>
</div>
<a id="gaa0f2023f35dc3e7aef1380dfae9b4007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0f2023f35dc3e7aef1380dfae9b4007">&#9670;&nbsp;</a></span>ad_spi_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking read transaction. </p>
<p>This function performs a synchronous read only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </dd>
<dd>
<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga87bc5d728492bf6daea7208723d1ee8f" title="Close SPI controller.">ad_spi_close()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer address and length must be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a id="gab28b8e6b379690f4ecdfb52d920849f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28b8e6b379690f4ecdfb52d920849f9">&#9670;&nbsp;</a></span>ad_spi_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ad_spi_user_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking read transaction. </p>
<p>This function performs a synchronous read only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error </dd></dl>

</div>
</div>
<a id="ga4a4bde8796de722afe47f30e731bec2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a4bde8796de722afe47f30e731bec2f">&#9670;&nbsp;</a></span>ad_spi_reconfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_reconfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__spi__driver__conf__t.html">ad_spi_driver_conf_t</a> *&#160;</td>
          <td class="paramname"><em>drv_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure SPI controller. </p>
<p>This function will apply a new SPI driver configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drv_conf</td><td>new driver configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>No change in I/O configuration is done. </dd></dl>

</div>
</div>
<a id="gadf999ddb5965f123661f8939ccaa83ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf999ddb5965f123661f8939ccaa83ff">&#9670;&nbsp;</a></span>ad_spi_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking write transaction. </p>
<p>This function performs a synchronous write only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In slave mode, the first word to be transmitted should be written to the TX buffer and the remaining words are written to the TX FIFO. Moreover, there are cases where the <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gadf999ddb5965f123661f8939ccaa83ff" title="Perform a blocking write transaction.">ad_spi_write()</a> is non-blocking. In such cases, the application should resolve this by a higher layer protocol. Otherwise, ad_spi_writeread() can be used where the incoming buffer is set to NULL, i.e. used in write only mode. This is always blocking because the terminating event is triggered when all bytes are received.<ul>
<li>TX FIFO width = 8 bits and depth = 4 Bytes</li>
<li>TX Buffer = 32 bits</li>
</ul>
<ol type="1">
<li>SPI_WORD_LENGTH = 3..7 =&gt; word size = 1 Byte: a. wlen = 1 (DMA is not enabled), b. wlen = 2 and SPI_TX_TL = 0..4, c. wlen = 3 and SPI_TX_TL = 1..4, d. wlen = 4 and SPI_TX_TL = 2..4, e. wlen = 5 and SPI_TX_TL = 3..4, and f. wlen &gt; 5 and SPI_TX_TL = 4.</li>
<li>SPI_WORD_LENGTH = 8..15 =&gt; word size = 2 Bytes: a. wlen = 2 (DMA is not enabled), b. wlen = 4 and SPI_TX_TL = 0..4, c. wlen = 6 and SPI_TX_TL = 2..4, d. wlen &gt;= 8 and SPI_TX_TL = 4.</li>
<li>SPI_WORD_LENGTH = 16..31 =&gt; word size = 4 Bytes: a. wlen = 4 (DMA is not enabled), b. wlen = 8 and SPI_TX_TL = 0..4, and c. wlen &gt;= 12 and SPI_TX_TL = 4.</li>
</ol>
</dd></dl>
<p>The mechanism that fetches data into the TX fifo and from TX fifo to TX buffer is as follows:</p>
<p>DMA mode: When data is to be transmitted in Slave mode using DMA, the first word is written to SPI_TXBUFFER_FORCE_REG and the DMA is programmed to send the remaining words. When the number of bytes in the TX fifo is less or equal to the TX threshold level set by the user (SPI_TX_TL), an SPI_STATUS_TX_EMPTY event triggers the DMA to fetch new data into the TX FIFO. When the last byte is added in the TX fifo, the dma has finished, the TX dma callback is called and <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gadf999ddb5965f123661f8939ccaa83ff" title="Perform a blocking write transaction.">ad_spi_write()</a> returns. This means that for the TX Path, there is no signal notifying about the actual transmission of the last byte on the bus.</p>
<p>Interrupt mode: When the number of bytes in the TX fifo is less or equal to the TX threshold level set by the user (SPI_TX_TL), an SPI_STATUS_TX_EMPTY event triggers the spi interrupt handler, which adds new data in the TX fifo. The user callback is called when the last byte is added in the TX fifo.</p>
<p>Case 1.a: In the special case where only one word needs to be sent, DMA cannot not be enabled to send zero words, although DMA may have been requested by the user during driver initialization. Instead, interrupt mode will be enabled for receiving an asynchronous notification and eventually call the user callback as required by the driver API.</p>
<p>Case 1.b: In the special case where two words needs to be sent, DMA will be enabled. The first word is written to SPI_TXBUFFER_FORCE_REG and the DMA is programmed to send the remaining word. The first time, the TX fifo is always empty i.e. it always has less or equal bytes to the TX threshold level set by the user (SPI_TX_TL). Therefore, an SPI_STATUS_TX_EMPTY event triggers the DMA to fetch a new word into the TX FIFO. When the last and only one word is added in the TX fifo, the dma has finished and the TX dma callback is called.</p>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer address and length must be non-zero and SPI-word-aligned </dd></dl>

</div>
</div>
<a id="ga0ae932834a8881d369ecd99554dadd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae932834a8881d369ecd99554dadd00">&#9670;&nbsp;</a></span>ad_spi_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ad_spi_user_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a non blocking write transaction. </p>
<p>This function performs an asynchronous write only transaction Caller task should retry until function returns no error Callback will be called when transaction is completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error </dd></dl>

</div>
</div>
<a id="gaa2136e116fc5f113e2c8aa2b8b06e20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2136e116fc5f113e2c8aa2b8b06e20d">&#9670;&nbsp;</a></span>ad_spi_write_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_write_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking write and read transaction. </p>
<p>This function performs a synchronous write and read transaction If wbuf is NULL then the function is used to read data If rbuf is NULL then the function is used to write data Buffers wbuf and rbuf cannot be both NULL</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>size of data to be sent/read to the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer address and length must be SPI-word-aligned (DA1468X and DA1469X: no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a id="gaa631aa63d1612b22b634b649d0283d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa631aa63d1612b22b634b649d0283d1d">&#9670;&nbsp;</a></span>ad_spi_write_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_spi_write_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf393399e8a808b2ab8e0f0e4d10ed0bd">ad_spi_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ad_spi_user_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform asynchronous SPI write and then read transaction. It can be used as write command and read buffer operation. </p>
<p>This function performs write command and read buffer transaction on SPI bus. The device and the bus resources must have been acquired and the chip select must be activated before calling this function. This can be achieved by calling ad_spi_start(). The callback function is executed when transaction has been completed. At this point SPI data are available to be used by the application. In the callback function one of the following actions can be performed:</p><ul>
<li>Read or write additional data by calling ad_spi_async_read() / ad_spi_async_write()</li>
<li>Notify application task that SPI transaction has been completed. ad_spi_end() must be called from application task context.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle returned from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gacd6cb5779fa025745f6c390d17db7347" title="Open SPI controller.">ad_spi_open()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2025 18:15:25 for SmartSnippets DA1459x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
